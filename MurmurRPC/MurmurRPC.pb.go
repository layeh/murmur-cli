// Code generated by protoc-gen-go.
// source: MurmurRPC.proto
// DO NOT EDIT!

/*
Package MurmurRPC is a generated protocol buffer package.

It is generated from these files:
	MurmurRPC.proto

It has these top-level messages:
	Void
	Version
	Uptime
	Server
	Event
	ContextAction
	TextMessage
	Log
	Config
	Channel
	User
	Tree
	Ban
	ACL
	Authenticator
	DatabaseUser
	RedirectWhisperGroup
*/
package MurmurRPC

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Server_Event_Type int32

const (
	Server_Event_UserConnected       Server_Event_Type = 0
	Server_Event_UserDisconnected    Server_Event_Type = 1
	Server_Event_UserStateChanged    Server_Event_Type = 2
	Server_Event_UserTextMessage     Server_Event_Type = 3
	Server_Event_ChannelCreated      Server_Event_Type = 4
	Server_Event_ChannelRemoved      Server_Event_Type = 5
	Server_Event_ChannelStateChanged Server_Event_Type = 6
)

var Server_Event_Type_name = map[int32]string{
	0: "UserConnected",
	1: "UserDisconnected",
	2: "UserStateChanged",
	3: "UserTextMessage",
	4: "ChannelCreated",
	5: "ChannelRemoved",
	6: "ChannelStateChanged",
}
var Server_Event_Type_value = map[string]int32{
	"UserConnected":       0,
	"UserDisconnected":    1,
	"UserStateChanged":    2,
	"UserTextMessage":     3,
	"ChannelCreated":      4,
	"ChannelRemoved":      5,
	"ChannelStateChanged": 6,
}

func (x Server_Event_Type) Enum() *Server_Event_Type {
	p := new(Server_Event_Type)
	*p = x
	return p
}
func (x Server_Event_Type) String() string {
	return proto.EnumName(Server_Event_Type_name, int32(x))
}
func (x *Server_Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Server_Event_Type_value, data, "Server_Event_Type")
	if err != nil {
		return err
	}
	*x = Server_Event_Type(value)
	return nil
}
func (Server_Event_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0, 0} }

type Event_Type int32

const (
	Event_ServerStopped Event_Type = 0
	Event_ServerStarted Event_Type = 1
)

var Event_Type_name = map[int32]string{
	0: "ServerStopped",
	1: "ServerStarted",
}
var Event_Type_value = map[string]int32{
	"ServerStopped": 0,
	"ServerStarted": 1,
}

func (x Event_Type) Enum() *Event_Type {
	p := new(Event_Type)
	*p = x
	return p
}
func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (x *Event_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_Type_value, data, "Event_Type")
	if err != nil {
		return err
	}
	*x = Event_Type(value)
	return nil
}
func (Event_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type ContextAction_Context int32

const (
	ContextAction_Server  ContextAction_Context = 1
	ContextAction_Channel ContextAction_Context = 2
	ContextAction_User    ContextAction_Context = 4
)

var ContextAction_Context_name = map[int32]string{
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextAction_Context_value = map[string]int32{
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextAction_Context) Enum() *ContextAction_Context {
	p := new(ContextAction_Context)
	*p = x
	return p
}
func (x ContextAction_Context) String() string {
	return proto.EnumName(ContextAction_Context_name, int32(x))
}
func (x *ContextAction_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextAction_Context_value, data, "ContextAction_Context")
	if err != nil {
		return err
	}
	*x = ContextAction_Context(value)
	return nil
}
func (ContextAction_Context) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type TextMessage_Filter_Action int32

const (
	// Accept the message.
	TextMessage_Filter_Accept TextMessage_Filter_Action = 0
	// Reject the message with a permission error.
	TextMessage_Filter_Reject TextMessage_Filter_Action = 1
	// Silently drop the message.
	TextMessage_Filter_Drop TextMessage_Filter_Action = 2
)

var TextMessage_Filter_Action_name = map[int32]string{
	0: "Accept",
	1: "Reject",
	2: "Drop",
}
var TextMessage_Filter_Action_value = map[string]int32{
	"Accept": 0,
	"Reject": 1,
	"Drop":   2,
}

func (x TextMessage_Filter_Action) Enum() *TextMessage_Filter_Action {
	p := new(TextMessage_Filter_Action)
	*p = x
	return p
}
func (x TextMessage_Filter_Action) String() string {
	return proto.EnumName(TextMessage_Filter_Action_name, int32(x))
}
func (x *TextMessage_Filter_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TextMessage_Filter_Action_value, data, "TextMessage_Filter_Action")
	if err != nil {
		return err
	}
	*x = TextMessage_Filter_Action(value)
	return nil
}
func (TextMessage_Filter_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0, 0}
}

type ACL_Permission int32

const (
	ACL_None                 ACL_Permission = 0
	ACL_Write                ACL_Permission = 1
	ACL_Traverse             ACL_Permission = 2
	ACL_Enter                ACL_Permission = 4
	ACL_Speak                ACL_Permission = 8
	ACL_Whisper              ACL_Permission = 256
	ACL_MuteDeafen           ACL_Permission = 16
	ACL_Move                 ACL_Permission = 32
	ACL_MakeChannel          ACL_Permission = 64
	ACL_MakeTemporaryChannel ACL_Permission = 1024
	ACL_LinkChannel          ACL_Permission = 128
	ACL_TextMessage          ACL_Permission = 512
	ACL_Kick                 ACL_Permission = 65536
	ACL_Ban                  ACL_Permission = 131072
	ACL_Register             ACL_Permission = 262144
	ACL_RegisterSelf         ACL_Permission = 524288
)

var ACL_Permission_name = map[int32]string{
	0:      "None",
	1:      "Write",
	2:      "Traverse",
	4:      "Enter",
	8:      "Speak",
	256:    "Whisper",
	16:     "MuteDeafen",
	32:     "Move",
	64:     "MakeChannel",
	1024:   "MakeTemporaryChannel",
	128:    "LinkChannel",
	512:    "TextMessage",
	65536:  "Kick",
	131072: "Ban",
	262144: "Register",
	524288: "RegisterSelf",
}
var ACL_Permission_value = map[string]int32{
	"None":                 0,
	"Write":                1,
	"Traverse":             2,
	"Enter":                4,
	"Speak":                8,
	"Whisper":              256,
	"MuteDeafen":           16,
	"Move":                 32,
	"MakeChannel":          64,
	"MakeTemporaryChannel": 1024,
	"LinkChannel":          128,
	"TextMessage":          512,
	"Kick":                 65536,
	"Ban":                  131072,
	"Register":             262144,
	"RegisterSelf":         524288,
}

func (x ACL_Permission) Enum() *ACL_Permission {
	p := new(ACL_Permission)
	*p = x
	return p
}
func (x ACL_Permission) String() string {
	return proto.EnumName(ACL_Permission_name, int32(x))
}
func (x *ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ACL_Permission_value, data, "ACL_Permission")
	if err != nil {
		return err
	}
	*x = ACL_Permission(value)
	return nil
}
func (ACL_Permission) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

type Authenticator_Response_Status int32

const (
	// The request should fallthrough to murmur's default action.
	Authenticator_Response_Fallthrough Authenticator_Response_Status = 0
	// The request was successful.
	Authenticator_Response_Success Authenticator_Response_Status = 1
	// The request failed; there was some error.
	Authenticator_Response_Failure Authenticator_Response_Status = 2
	// A temporary failure prevented the request from succeeding (e.g. a
	// database was unavailable).
	Authenticator_Response_TemporaryFailure Authenticator_Response_Status = 3
)

var Authenticator_Response_Status_name = map[int32]string{
	0: "Fallthrough",
	1: "Success",
	2: "Failure",
	3: "TemporaryFailure",
}
var Authenticator_Response_Status_value = map[string]int32{
	"Fallthrough":      0,
	"Success":          1,
	"Failure":          2,
	"TemporaryFailure": 3,
}

func (x Authenticator_Response_Status) Enum() *Authenticator_Response_Status {
	p := new(Authenticator_Response_Status)
	*p = x
	return p
}
func (x Authenticator_Response_Status) String() string {
	return proto.EnumName(Authenticator_Response_Status_name, int32(x))
}
func (x *Authenticator_Response_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Authenticator_Response_Status_value, data, "Authenticator_Response_Status")
	if err != nil {
		return err
	}
	*x = Authenticator_Response_Status(value)
	return nil
}
func (Authenticator_Response_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 0}
}

type Void struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version,json=osVersion" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

type Uptime struct {
	// The number of seconds from the starting time.
	Secs             *uint64 `protobuf:"varint,1,opt,name=secs" json:"secs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Uptime) Reset()                    { *m = Uptime{} }
func (m *Uptime) String() string            { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()               {}
func (*Uptime) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Uptime) GetSecs() uint64 {
	if m != nil && m.Secs != nil {
		return *m.Secs
	}
	return 0
}

type Server struct {
	// The unique server ID.
	Id *uint32 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Is the server currently running?
	Running *bool `protobuf:"varint,2,opt,name=running" json:"running,omitempty"`
	// The update of the server.
	Uptime           *Uptime `protobuf:"bytes,3,opt,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Server) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Server) GetRunning() bool {
	if m != nil && m.Running != nil {
		return *m.Running
	}
	return false
}

func (m *Server) GetUptime() *Uptime {
	if m != nil {
		return m.Uptime
	}
	return nil
}

type Server_Event struct {
	// The server on which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type *Server_Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Server_Event_Type" json:"type,omitempty"`
	// The user tied to the event (if applicable).
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The text message tied to the event (if applicable).
	Message *TextMessage `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	// The channel tied to the event (if applicable).
	Channel          *Channel `protobuf:"bytes,5,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Server_Event) Reset()                    { *m = Server_Event{} }
func (m *Server_Event) String() string            { return proto.CompactTextString(m) }
func (*Server_Event) ProtoMessage()               {}
func (*Server_Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *Server_Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Server_Event) GetType() Server_Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Server_Event_UserConnected
}

func (m *Server_Event) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Server_Event) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Server_Event) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type Server_Query struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Server_Query) Reset()                    { *m = Server_Query{} }
func (m *Server_Query) String() string            { return proto.CompactTextString(m) }
func (*Server_Query) ProtoMessage()               {}
func (*Server_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

type Server_List struct {
	// The servers.
	Servers          []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Server_List) Reset()                    { *m = Server_List{} }
func (m *Server_List) String() string            { return proto.CompactTextString(m) }
func (*Server_List) ProtoMessage()               {}
func (*Server_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 2} }

func (m *Server_List) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

type Event struct {
	// The server for which the event happened.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The type of event that happened.
	Type             *Event_Type `protobuf:"varint,2,opt,name=type,enum=MurmurRPC.Event_Type" json:"type,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Event) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Event) GetType() Event_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Event_ServerStopped
}

type ContextAction struct {
	// The server on which the action is.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The context in which the action is.
	Context *uint32 `protobuf:"varint,2,opt,name=context" json:"context,omitempty"`
	// The action name.
	Action *string `protobuf:"bytes,3,opt,name=action" json:"action,omitempty"`
	// The user-visible descriptive name of the action.
	Text *string `protobuf:"bytes,4,opt,name=text" json:"text,omitempty"`
	// The user that triggered the ContextAction.
	Actor *User `protobuf:"bytes,5,opt,name=actor" json:"actor,omitempty"`
	// The user on which the ContextAction was triggered.
	User *User `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The channel on which the ContextAction was triggered.
	Channel          *Channel `protobuf:"bytes,7,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ContextAction) Reset()                    { *m = ContextAction{} }
func (m *ContextAction) String() string            { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()               {}
func (*ContextAction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ContextAction) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ContextAction) GetContext() uint32 {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return 0
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextAction) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextAction) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *ContextAction) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ContextAction) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type TextMessage struct {
	// The server on which the TextMessage originates.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user who sent the message.
	Actor *User `protobuf:"bytes,2,opt,name=actor" json:"actor,omitempty"`
	// The users to whom the message is sent.
	Users []*User `protobuf:"bytes,3,rep,name=users" json:"users,omitempty"`
	// The channels to which the message is sent.
	Channels []*Channel `protobuf:"bytes,4,rep,name=channels" json:"channels,omitempty"`
	// The channels to which the message is sent, including the channels'
	// ancestors.
	Trees []*Channel `protobuf:"bytes,5,rep,name=trees" json:"trees,omitempty"`
	// The message body that is sent.
	Text             *string `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TextMessage) Reset()                    { *m = TextMessage{} }
func (m *TextMessage) String() string            { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()               {}
func (*TextMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TextMessage) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *TextMessage) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *TextMessage) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *TextMessage) GetTrees() []*Channel {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *TextMessage) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type TextMessage_Filter struct {
	// The server on which the message originated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The action to perform for the message.
	Action *TextMessage_Filter_Action `protobuf:"varint,2,opt,name=action,enum=MurmurRPC.TextMessage_Filter_Action" json:"action,omitempty"`
	// The text message.
	Message          *TextMessage `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TextMessage_Filter) Reset()                    { *m = TextMessage_Filter{} }
func (m *TextMessage_Filter) String() string            { return proto.CompactTextString(m) }
func (*TextMessage_Filter) ProtoMessage()               {}
func (*TextMessage_Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *TextMessage_Filter) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *TextMessage_Filter) GetAction() TextMessage_Filter_Action {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return TextMessage_Filter_Accept
}

func (m *TextMessage_Filter) GetMessage() *TextMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type Log struct {
	// The server on which the log message was generated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unix timestamp of when the message was generated.
	Timestamp *int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// The log message.
	Text             *string `protobuf:"bytes,3,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Log) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Log) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type Log_Query struct {
	// The server whose logs will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The minimum log index to receive.
	Min *uint32 `protobuf:"varint,2,opt,name=min" json:"min,omitempty"`
	// The maximum log index to receive.
	Max              *uint32 `protobuf:"varint,3,opt,name=max" json:"max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Log_Query) Reset()                    { *m = Log_Query{} }
func (m *Log_Query) String() string            { return proto.CompactTextString(m) }
func (*Log_Query) ProtoMessage()               {}
func (*Log_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Log_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_Query) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_Query) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

type Log_List struct {
	// The server where the log entries are from.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The total number of logs entries on the server.
	Total *uint32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
	// The minimum log index that was sent.
	Min *uint32 `protobuf:"varint,3,opt,name=min" json:"min,omitempty"`
	// The maximum log index that was sent.
	Max *uint32 `protobuf:"varint,4,opt,name=max" json:"max,omitempty"`
	// The log entries.
	Entries          []*Log `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Log_List) Reset()                    { *m = Log_List{} }
func (m *Log_List) String() string            { return proto.CompactTextString(m) }
func (*Log_List) ProtoMessage()               {}
func (*Log_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *Log_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Log_List) GetTotal() uint32 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

func (m *Log_List) GetMin() uint32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

func (m *Log_List) GetMax() uint32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *Log_List) GetEntries() []*Log {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Config struct {
	// The server for which the configuration is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The configuration keys and values.
	Fields           map[string]string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Config) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Config_Field struct {
	// The server for which the configuration field is for.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The field key.
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// The field value.
	Value            *string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Config_Field) Reset()                    { *m = Config_Field{} }
func (m *Config_Field) String() string            { return proto.CompactTextString(m) }
func (*Config_Field) ProtoMessage()               {}
func (*Config_Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *Config_Field) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Config_Field) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Config_Field) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Channel struct {
	// The server on which the channel exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique channel identifier.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The channel's parent.
	Parent *Channel `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	// Linked channels.
	Links []*Channel `protobuf:"bytes,5,rep,name=links" json:"links,omitempty"`
	// The channel's description.
	Description *string `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	// Is the channel temporary?
	Temporary *bool `protobuf:"varint,7,opt,name=temporary" json:"temporary,omitempty"`
	// The position in which the channel should appear in a sorted list.
	Position         *int32 `protobuf:"varint,8,opt,name=position" json:"position,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Channel) Reset()                    { *m = Channel{} }
func (m *Channel) String() string            { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()               {}
func (*Channel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Channel) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Channel) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Channel) GetParent() *Channel {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *Channel) GetLinks() []*Channel {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Channel) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Channel) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return false
}

func (m *Channel) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

type Channel_Query struct {
	// The server on which the channels are.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Channel_Query) Reset()                    { *m = Channel_Query{} }
func (m *Channel_Query) String() string            { return proto.CompactTextString(m) }
func (*Channel_Query) ProtoMessage()               {}
func (*Channel_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *Channel_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Channel_List struct {
	// The server on which the channels are.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channels.
	Channels         []*Channel `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Channel_List) Reset()                    { *m = Channel_List{} }
func (m *Channel_List) String() string            { return proto.CompactTextString(m) }
func (*Channel_List) ProtoMessage()               {}
func (*Channel_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 1} }

func (m *Channel_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Channel_List) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type User struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's session ID.
	Session *uint32 `protobuf:"varint,2,opt,name=session" json:"session,omitempty"`
	// The user's registered ID.
	Id *uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Is the user muted?
	Mute *bool `protobuf:"varint,5,opt,name=mute" json:"mute,omitempty"`
	// Is the user deafened?
	Deaf *bool `protobuf:"varint,6,opt,name=deaf" json:"deaf,omitempty"`
	// Is the user suppressed?
	Suppress *bool `protobuf:"varint,7,opt,name=suppress" json:"suppress,omitempty"`
	// Is the user a priority speaker?
	PrioritySpeaker *bool `protobuf:"varint,8,opt,name=priority_speaker,json=prioritySpeaker" json:"priority_speaker,omitempty"`
	// Has the user muted him/herself?
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute,json=selfMute" json:"self_mute,omitempty"`
	// Has the user muted him/herself?
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf,json=selfDeaf" json:"self_deaf,omitempty"`
	// Is the user recording?
	Recording *bool `protobuf:"varint,11,opt,name=recording" json:"recording,omitempty"`
	// The channel the user is in.
	Channel *Channel `protobuf:"bytes,12,opt,name=channel" json:"channel,omitempty"`
	// How long the user has been connected to the server.
	OnlineSecs *uint32 `protobuf:"varint,13,opt,name=online_secs,json=onlineSecs" json:"online_secs,omitempty"`
	// How long the user has been idle on the server.
	IdleSecs *uint32 `protobuf:"varint,14,opt,name=idle_secs,json=idleSecs" json:"idle_secs,omitempty"`
	// How many bytes per second is the user transmitting to the server.
	BytesPerSec *uint32 `protobuf:"varint,15,opt,name=bytes_per_sec,json=bytesPerSec" json:"bytes_per_sec,omitempty"`
	// The user's client version.
	Version *Version `protobuf:"bytes,16,opt,name=version" json:"version,omitempty"`
	// The user's  plugin context.
	PluginContext []byte `protobuf:"bytes,17,opt,name=plugin_context,json=pluginContext" json:"plugin_context,omitempty"`
	// The user's plugin identity.
	PluginIdentity *string `protobuf:"bytes,18,opt,name=plugin_identity,json=pluginIdentity" json:"plugin_identity,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,19,opt,name=comment" json:"comment,omitempty"`
	// The user's texture.
	Texture []byte `protobuf:"bytes,20,opt,name=texture" json:"texture,omitempty"`
	// The user's IP address.
	Address []byte `protobuf:"bytes,21,opt,name=address" json:"address,omitempty"`
	// Is the user in TCP-only mode?
	TcpOnly *bool `protobuf:"varint,22,opt,name=tcp_only,json=tcpOnly" json:"tcp_only,omitempty"`
	// The user's UDP ping in milliseconds.
	UdpPingMsecs *float32 `protobuf:"fixed32,23,opt,name=udp_ping_msecs,json=udpPingMsecs" json:"udp_ping_msecs,omitempty"`
	// The user's TCP ping in milliseconds.
	TcpPingMsecs     *float32 `protobuf:"fixed32,24,opt,name=tcp_ping_msecs,json=tcpPingMsecs" json:"tcp_ping_msecs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *User) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *User) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *User) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *User) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *User) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *User) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *User) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *User) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *User) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

func (m *User) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *User) GetOnlineSecs() uint32 {
	if m != nil && m.OnlineSecs != nil {
		return *m.OnlineSecs
	}
	return 0
}

func (m *User) GetIdleSecs() uint32 {
	if m != nil && m.IdleSecs != nil {
		return *m.IdleSecs
	}
	return 0
}

func (m *User) GetBytesPerSec() uint32 {
	if m != nil && m.BytesPerSec != nil {
		return *m.BytesPerSec
	}
	return 0
}

func (m *User) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *User) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *User) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *User) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *User) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *User) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *User) GetTcpOnly() bool {
	if m != nil && m.TcpOnly != nil {
		return *m.TcpOnly
	}
	return false
}

func (m *User) GetUdpPingMsecs() float32 {
	if m != nil && m.UdpPingMsecs != nil {
		return *m.UdpPingMsecs
	}
	return 0
}

func (m *User) GetTcpPingMsecs() float32 {
	if m != nil && m.TcpPingMsecs != nil {
		return *m.TcpPingMsecs
	}
	return 0
}

type User_Query struct {
	// The server whose users will be queried.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Query) Reset()                    { *m = User_Query{} }
func (m *User_Query) String() string            { return proto.CompactTextString(m) }
func (*User_Query) ProtoMessage()               {}
func (*User_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *User_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type User_List struct {
	// The server to which the users are connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*User `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_List) Reset()                    { *m = User_List{} }
func (m *User_List) String() string            { return proto.CompactTextString(m) }
func (*User_List) ProtoMessage()               {}
func (*User_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

func (m *User_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_List) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type User_Kick struct {
	// The server to which the user is connected.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to kick.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The user who performed the kick.
	Actor *User `protobuf:"bytes,3,opt,name=actor" json:"actor,omitempty"`
	// The reason for why the user is being kicked.
	Reason           *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *User_Kick) Reset()                    { *m = User_Kick{} }
func (m *User_Kick) String() string            { return proto.CompactTextString(m) }
func (*User_Kick) ProtoMessage()               {}
func (*User_Kick) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 2} }

func (m *User_Kick) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *User_Kick) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *User_Kick) GetActor() *User {
	if m != nil {
		return m.Actor
	}
	return nil
}

func (m *User_Kick) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

type Tree struct {
	// The server which the tree represents.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The current channel.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// Channels below the current channel.
	Children []*Tree `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	// The users in the current channel.
	Users            []*User `protobuf:"bytes,4,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree) Reset()                    { *m = Tree{} }
func (m *Tree) String() string            { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()               {}
func (*Tree) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Tree) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Tree) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *Tree) GetChildren() []*Tree {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Tree) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type Tree_Query struct {
	// The server to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tree_Query) Reset()                    { *m = Tree_Query{} }
func (m *Tree_Query) String() string            { return proto.CompactTextString(m) }
func (*Tree_Query) ProtoMessage()               {}
func (*Tree_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

func (m *Tree_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban struct {
	// The server on which the ban is applied.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The banned IP address.
	Address []byte `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	// The number of leading bits in the address to which the ban applies.
	Bits *uint32 `protobuf:"varint,3,opt,name=bits" json:"bits,omitempty"`
	// The name of the banned user.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// The certificate hash of the banned user.
	Hash *string `protobuf:"bytes,5,opt,name=hash" json:"hash,omitempty"`
	// The reason for the ban.
	Reason *string `protobuf:"bytes,6,opt,name=reason" json:"reason,omitempty"`
	// The ban start time (in epoch form).
	Start *int64 `protobuf:"varint,7,opt,name=start" json:"start,omitempty"`
	// The ban duration.
	DurationSecs     *int64 `protobuf:"varint,8,opt,name=duration_secs,json=durationSecs" json:"duration_secs,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban) Reset()                    { *m = Ban{} }
func (m *Ban) String() string            { return proto.CompactTextString(m) }
func (*Ban) ProtoMessage()               {}
func (*Ban) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Ban) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Ban) GetBits() uint32 {
	if m != nil && m.Bits != nil {
		return *m.Bits
	}
	return 0
}

func (m *Ban) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ban) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *Ban) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *Ban) GetStart() int64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *Ban) GetDurationSecs() int64 {
	if m != nil && m.DurationSecs != nil {
		return *m.DurationSecs
	}
	return 0
}

type Ban_Query struct {
	// The server whose bans to query.
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ban_Query) Reset()                    { *m = Ban_Query{} }
func (m *Ban_Query) String() string            { return proto.CompactTextString(m) }
func (*Ban_Query) ProtoMessage()               {}
func (*Ban_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

func (m *Ban_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Ban_List struct {
	// The server for which the bans apply.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The bans.
	Bans             []*Ban `protobuf:"bytes,2,rep,name=bans" json:"bans,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ban_List) Reset()                    { *m = Ban_List{} }
func (m *Ban_List) String() string            { return proto.CompactTextString(m) }
func (*Ban_List) ProtoMessage()               {}
func (*Ban_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 1} }

func (m *Ban_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *Ban_List) GetBans() []*Ban {
	if m != nil {
		return m.Bans
	}
	return nil
}

type ACL struct {
	// Does the ACL apply to the current channel?
	ApplyHere *bool `protobuf:"varint,3,opt,name=apply_here,json=applyHere" json:"apply_here,omitempty"`
	// Does the ACL apply to the current channel's sub-channels?
	ApplySubs *bool `protobuf:"varint,4,opt,name=apply_subs,json=applySubs" json:"apply_subs,omitempty"`
	// Was the ACL inherited?
	Inherited *bool `protobuf:"varint,5,opt,name=inherited" json:"inherited,omitempty"`
	// The user to whom the ACL applies.
	User *DatabaseUser `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	// The group to whom the ACL applies.
	Group *ACL_Group `protobuf:"bytes,7,opt,name=group" json:"group,omitempty"`
	// The permissions granted by the ACL (bitmask of ACL.Permission).
	Allow *uint32 `protobuf:"varint,8,opt,name=allow" json:"allow,omitempty"`
	// The permissions denied by the ACL (bitmask of ACL.Permission).
	Deny             *uint32 `protobuf:"varint,9,opt,name=deny" json:"deny,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL) Reset()                    { *m = ACL{} }
func (m *ACL) String() string            { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()               {}
func (*ACL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return false
}

func (m *ACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return false
}

func (m *ACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL) GetGroup() *ACL_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ACL) GetAllow() uint32 {
	if m != nil && m.Allow != nil {
		return *m.Allow
	}
	return 0
}

func (m *ACL) GetDeny() uint32 {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return 0
}

type ACL_Group struct {
	// The ACL group name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Is the group inherited?
	Inherited *bool `protobuf:"varint,2,opt,name=inherited" json:"inherited,omitempty"`
	// Does the group inherit members?
	Inherit *bool `protobuf:"varint,3,opt,name=inherit" json:"inherit,omitempty"`
	// Can this group be inherited by its children?
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable" json:"inheritable,omitempty"`
	// The users explicitly added by this group.
	UsersAdd []*DatabaseUser `protobuf:"bytes,5,rep,name=users_add,json=usersAdd" json:"users_add,omitempty"`
	// The users explicitly removed by this group.
	UsersRemove []*DatabaseUser `protobuf:"bytes,6,rep,name=users_remove,json=usersRemove" json:"users_remove,omitempty"`
	// All of the users who are part of this group.
	Users            []*DatabaseUser `protobuf:"bytes,7,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ACL_Group) Reset()                    { *m = ACL_Group{} }
func (m *ACL_Group) String() string            { return proto.CompactTextString(m) }
func (*ACL_Group) ProtoMessage()               {}
func (*ACL_Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

func (m *ACL_Group) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_Group) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return false
}

func (m *ACL_Group) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

func (m *ACL_Group) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return false
}

func (m *ACL_Group) GetUsersAdd() []*DatabaseUser {
	if m != nil {
		return m.UsersAdd
	}
	return nil
}

func (m *ACL_Group) GetUsersRemove() []*DatabaseUser {
	if m != nil {
		return m.UsersRemove
	}
	return nil
}

func (m *ACL_Group) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ACL_Query struct {
	// The server where the user and channel exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to query.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The channel to query.
	Channel          *Channel `protobuf:"bytes,3,opt,name=channel" json:"channel,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_Query) Reset()                    { *m = ACL_Query{} }
func (m *ACL_Query) String() string            { return proto.CompactTextString(m) }
func (*ACL_Query) ProtoMessage()               {}
func (*ACL_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 1} }

func (m *ACL_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_Query) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_Query) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type ACL_List struct {
	// The server on which the ACLs exist.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the ACL refers.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The ACLs part of the given channel.
	Acls []*ACL `protobuf:"bytes,3,rep,name=acls" json:"acls,omitempty"`
	// The groups part of the given channel.
	Groups []*ACL_Group `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	// Should ACLs be inherited from the parent channel.
	Inherit          *bool  `protobuf:"varint,5,opt,name=inherit" json:"inherit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL_List) Reset()                    { *m = ACL_List{} }
func (m *ACL_List) String() string            { return proto.CompactTextString(m) }
func (*ACL_List) ProtoMessage()               {}
func (*ACL_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 2} }

func (m *ACL_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_List) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_List) GetAcls() []*ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL_List) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL_List) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return false
}

type ACL_TemporaryGroup struct {
	// The server where the temporary group exists.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The channel to which the temporary user group is added.
	Channel *Channel `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	// The user who is added to the group.
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// The name of the temporary group.
	Name             *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL_TemporaryGroup) Reset()                    { *m = ACL_TemporaryGroup{} }
func (m *ACL_TemporaryGroup) String() string            { return proto.CompactTextString(m) }
func (*ACL_TemporaryGroup) ProtoMessage()               {}
func (*ACL_TemporaryGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 3} }

func (m *ACL_TemporaryGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ACL_TemporaryGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Authenticator struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Authenticator) Reset()                    { *m = Authenticator{} }
func (m *Authenticator) String() string            { return proto.CompactTextString(m) }
func (*Authenticator) ProtoMessage()               {}
func (*Authenticator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type Authenticator_Request struct {
	Authenticate     *Authenticator_Request_Authenticate `protobuf:"bytes,1,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Request_Find         `protobuf:"bytes,2,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Request_Query        `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Request_Register     `protobuf:"bytes,4,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Request_Deregister   `protobuf:"bytes,5,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Request_Update       `protobuf:"bytes,6,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *Authenticator_Request) Reset()                    { *m = Authenticator_Request{} }
func (m *Authenticator_Request) String() string            { return proto.CompactTextString(m) }
func (*Authenticator_Request) ProtoMessage()               {}
func (*Authenticator_Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *Authenticator_Request) GetAuthenticate() *Authenticator_Request_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Request) GetFind() *Authenticator_Request_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Request) GetQuery() *Authenticator_Request_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Request) GetRegister() *Authenticator_Request_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Request) GetDeregister() *Authenticator_Request_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Request) GetUpdate() *Authenticator_Request_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// An authentication request for a connecting user.
type Authenticator_Request_Authenticate struct {
	// The user's name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The user's certificate chain in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// The hexadecimal hash of the user's certificate.
	CertificateHash *string `protobuf:"bytes,4,opt,name=certificate_hash,json=certificateHash" json:"certificate_hash,omitempty"`
	// If the user is connecting with a strong certificate.
	StrongCertificate *bool  `protobuf:"varint,5,opt,name=strong_certificate,json=strongCertificate" json:"strong_certificate,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *Authenticator_Request_Authenticate) Reset()         { *m = Authenticator_Request_Authenticate{} }
func (m *Authenticator_Request_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Authenticate) ProtoMessage()    {}
func (*Authenticator_Request_Authenticate) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 0}
}

func (m *Authenticator_Request_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetCertificates() [][]byte {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *Authenticator_Request_Authenticate) GetCertificateHash() string {
	if m != nil && m.CertificateHash != nil {
		return *m.CertificateHash
	}
	return ""
}

func (m *Authenticator_Request_Authenticate) GetStrongCertificate() bool {
	if m != nil && m.StrongCertificate != nil {
		return *m.StrongCertificate
	}
	return false
}

// A request for information about a user, given by either the user's ID
// or name.
type Authenticator_Request_Find struct {
	// The user's ID used for lookup.
	Id *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The user's name used for lookup.
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Find) Reset()         { *m = Authenticator_Request_Find{} }
func (m *Authenticator_Request_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Find) ProtoMessage()    {}
func (*Authenticator_Request_Find) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 1}
}

func (m *Authenticator_Request_Find) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Request_Find) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// A query of all the registered users, optionally filtered by the given
// filter string.
type Authenticator_Request_Query struct {
	// A user name filter (% is often used as a wildcard)
	Filter           *string `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Request_Query) Reset()         { *m = Authenticator_Request_Query{} }
func (m *Authenticator_Request_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Query) ProtoMessage()    {}
func (*Authenticator_Request_Query) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 2}
}

func (m *Authenticator_Request_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

// A request for a new user registration.
type Authenticator_Request_Register struct {
	// The database user to register.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Register) Reset()         { *m = Authenticator_Request_Register{} }
func (m *Authenticator_Request_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Register) ProtoMessage()    {}
func (*Authenticator_Request_Register) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 3}
}

func (m *Authenticator_Request_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request for deregistering a registered user.
type Authenticator_Request_Deregister struct {
	// The database user to deregister.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Deregister) Reset()         { *m = Authenticator_Request_Deregister{} }
func (m *Authenticator_Request_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Deregister) ProtoMessage()    {}
func (*Authenticator_Request_Deregister) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 4}
}

func (m *Authenticator_Request_Deregister) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

// A request to update a registered user's information. The information
// provided should be merged with existing data.
type Authenticator_Request_Update struct {
	// The database user to update.
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Request_Update) Reset()         { *m = Authenticator_Request_Update{} }
func (m *Authenticator_Request_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Request_Update) ProtoMessage()    {}
func (*Authenticator_Request_Update) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 0, 5}
}

func (m *Authenticator_Request_Update) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response struct {
	Initialize       *Authenticator_Response_Initialize   `protobuf:"bytes,1,opt,name=initialize" json:"initialize,omitempty"`
	Authenticate     *Authenticator_Response_Authenticate `protobuf:"bytes,2,opt,name=authenticate" json:"authenticate,omitempty"`
	Find             *Authenticator_Response_Find         `protobuf:"bytes,3,opt,name=find" json:"find,omitempty"`
	Query            *Authenticator_Response_Query        `protobuf:"bytes,4,opt,name=query" json:"query,omitempty"`
	Register         *Authenticator_Response_Register     `protobuf:"bytes,5,opt,name=register" json:"register,omitempty"`
	Deregister       *Authenticator_Response_Deregister   `protobuf:"bytes,6,opt,name=deregister" json:"deregister,omitempty"`
	Update           *Authenticator_Response_Update       `protobuf:"bytes,7,opt,name=update" json:"update,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *Authenticator_Response) Reset()                    { *m = Authenticator_Response{} }
func (m *Authenticator_Response) String() string            { return proto.CompactTextString(m) }
func (*Authenticator_Response) ProtoMessage()               {}
func (*Authenticator_Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 1} }

func (m *Authenticator_Response) GetInitialize() *Authenticator_Response_Initialize {
	if m != nil {
		return m.Initialize
	}
	return nil
}

func (m *Authenticator_Response) GetAuthenticate() *Authenticator_Response_Authenticate {
	if m != nil {
		return m.Authenticate
	}
	return nil
}

func (m *Authenticator_Response) GetFind() *Authenticator_Response_Find {
	if m != nil {
		return m.Find
	}
	return nil
}

func (m *Authenticator_Response) GetQuery() *Authenticator_Response_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Authenticator_Response) GetRegister() *Authenticator_Response_Register {
	if m != nil {
		return m.Register
	}
	return nil
}

func (m *Authenticator_Response) GetDeregister() *Authenticator_Response_Deregister {
	if m != nil {
		return m.Deregister
	}
	return nil
}

func (m *Authenticator_Response) GetUpdate() *Authenticator_Response_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// The initialization for the authenticator stream. This message must be
// sent before authentication requests will start streaming.
type Authenticator_Response_Initialize struct {
	Server           *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticator_Response_Initialize) Reset()         { *m = Authenticator_Response_Initialize{} }
func (m *Authenticator_Response_Initialize) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Initialize) ProtoMessage()    {}
func (*Authenticator_Response_Initialize) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 0}
}

func (m *Authenticator_Response_Initialize) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

type Authenticator_Response_Authenticate struct {
	// The status of the request.
	Status *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	// The user's registered ID.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The corrected user's name;
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Additional ACL groups that the user belongs too.
	Groups           []*ACL_Group `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Authenticator_Response_Authenticate) Reset()         { *m = Authenticator_Response_Authenticate{} }
func (m *Authenticator_Response_Authenticate) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Authenticate) ProtoMessage()    {}
func (*Authenticator_Response_Authenticate) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 1}
}

func (m *Authenticator_Response_Authenticate) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Authenticate) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Authenticator_Response_Authenticate) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Authenticator_Response_Authenticate) GetGroups() []*ACL_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Authenticator_Response_Find struct {
	// The database user (if found).
	User             *DatabaseUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Response_Find) Reset()         { *m = Authenticator_Response_Find{} }
func (m *Authenticator_Response_Find) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Find) ProtoMessage()    {}
func (*Authenticator_Response_Find) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 2}
}

func (m *Authenticator_Response_Find) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Query struct {
	// The matched database users.
	Users            []*DatabaseUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Authenticator_Response_Query) Reset()         { *m = Authenticator_Response_Query{} }
func (m *Authenticator_Response_Query) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Query) ProtoMessage()    {}
func (*Authenticator_Response_Query) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 3}
}

func (m *Authenticator_Response_Query) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type Authenticator_Response_Register struct {
	// The status of the request.
	Status *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	// The registered database user (must contain the registered user's ID).
	User             *DatabaseUser `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Authenticator_Response_Register) Reset()         { *m = Authenticator_Response_Register{} }
func (m *Authenticator_Response_Register) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Register) ProtoMessage()    {}
func (*Authenticator_Response_Register) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 4}
}

func (m *Authenticator_Response_Register) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

func (m *Authenticator_Response_Register) GetUser() *DatabaseUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Authenticator_Response_Deregister struct {
	// The status of the request.
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Deregister) Reset()         { *m = Authenticator_Response_Deregister{} }
func (m *Authenticator_Response_Deregister) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Deregister) ProtoMessage()    {}
func (*Authenticator_Response_Deregister) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 5}
}

func (m *Authenticator_Response_Deregister) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type Authenticator_Response_Update struct {
	// The status of the request.
	Status           *Authenticator_Response_Status `protobuf:"varint,1,opt,name=status,enum=MurmurRPC.Authenticator_Response_Status" json:"status,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *Authenticator_Response_Update) Reset()         { *m = Authenticator_Response_Update{} }
func (m *Authenticator_Response_Update) String() string { return proto.CompactTextString(m) }
func (*Authenticator_Response_Update) ProtoMessage()    {}
func (*Authenticator_Response_Update) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{14, 1, 6}
}

func (m *Authenticator_Response_Update) GetStatus() Authenticator_Response_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Authenticator_Response_Fallthrough
}

type DatabaseUser struct {
	// The server on which the user is registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The unique user ID.
	Id *uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The user's email address.
	Email *string `protobuf:"bytes,4,opt,name=email" json:"email,omitempty"`
	// The user's comment.
	Comment *string `protobuf:"bytes,5,opt,name=comment" json:"comment,omitempty"`
	// The user's certificate hash.
	Hash *string `protobuf:"bytes,6,opt,name=hash" json:"hash,omitempty"`
	// The user's password (never sent; used only when updating).
	Password *string `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	// When the user was last on the server.
	LastActive *string `protobuf:"bytes,8,opt,name=last_active,json=lastActive" json:"last_active,omitempty"`
	// The user's texture.
	Texture          []byte `protobuf:"bytes,9,opt,name=texture" json:"texture,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DatabaseUser) Reset()                    { *m = DatabaseUser{} }
func (m *DatabaseUser) String() string            { return proto.CompactTextString(m) }
func (*DatabaseUser) ProtoMessage()               {}
func (*DatabaseUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DatabaseUser) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *DatabaseUser) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser) GetEmail() string {
	if m != nil && m.Email != nil {
		return *m.Email
	}
	return ""
}

func (m *DatabaseUser) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *DatabaseUser) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *DatabaseUser) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *DatabaseUser) GetLastActive() string {
	if m != nil && m.LastActive != nil {
		return *m.LastActive
	}
	return ""
}

func (m *DatabaseUser) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

type DatabaseUser_Query struct {
	// The server whose users will be queried.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// A string to filter the users by.
	Filter           *string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Query) Reset()                    { *m = DatabaseUser_Query{} }
func (m *DatabaseUser_Query) String() string            { return proto.CompactTextString(m) }
func (*DatabaseUser_Query) ProtoMessage()               {}
func (*DatabaseUser_Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 0} }

func (m *DatabaseUser_Query) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Query) GetFilter() string {
	if m != nil && m.Filter != nil {
		return *m.Filter
	}
	return ""
}

type DatabaseUser_List struct {
	// The server on which the users are registered.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The users.
	Users            []*DatabaseUser `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DatabaseUser_List) Reset()                    { *m = DatabaseUser_List{} }
func (m *DatabaseUser_List) String() string            { return proto.CompactTextString(m) }
func (*DatabaseUser_List) ProtoMessage()               {}
func (*DatabaseUser_List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 1} }

func (m *DatabaseUser_List) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_List) GetUsers() []*DatabaseUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type DatabaseUser_Verify struct {
	// The server on which the user-password pair will be authenticated.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user's name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The user's password.
	Password         *string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatabaseUser_Verify) Reset()                    { *m = DatabaseUser_Verify{} }
func (m *DatabaseUser_Verify) String() string            { return proto.CompactTextString(m) }
func (*DatabaseUser_Verify) ProtoMessage()               {}
func (*DatabaseUser_Verify) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 2} }

func (m *DatabaseUser_Verify) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *DatabaseUser_Verify) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DatabaseUser_Verify) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type RedirectWhisperGroup struct {
	// The server on which the whisper redirection will take place.
	Server *Server `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// The user to whom the redirection will be applied.
	User *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// The source group.
	Source *ACL_Group `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	// The target group.
	Target           *ACL_Group `protobuf:"bytes,4,opt,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RedirectWhisperGroup) Reset()                    { *m = RedirectWhisperGroup{} }
func (m *RedirectWhisperGroup) String() string            { return proto.CompactTextString(m) }
func (*RedirectWhisperGroup) ProtoMessage()               {}
func (*RedirectWhisperGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RedirectWhisperGroup) GetServer() *Server {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RedirectWhisperGroup) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RedirectWhisperGroup) GetSource() *ACL_Group {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *RedirectWhisperGroup) GetTarget() *ACL_Group {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterType((*Void)(nil), "MurmurRPC.Void")
	proto.RegisterType((*Version)(nil), "MurmurRPC.Version")
	proto.RegisterType((*Uptime)(nil), "MurmurRPC.Uptime")
	proto.RegisterType((*Server)(nil), "MurmurRPC.Server")
	proto.RegisterType((*Server_Event)(nil), "MurmurRPC.Server.Event")
	proto.RegisterType((*Server_Query)(nil), "MurmurRPC.Server.Query")
	proto.RegisterType((*Server_List)(nil), "MurmurRPC.Server.List")
	proto.RegisterType((*Event)(nil), "MurmurRPC.Event")
	proto.RegisterType((*ContextAction)(nil), "MurmurRPC.ContextAction")
	proto.RegisterType((*TextMessage)(nil), "MurmurRPC.TextMessage")
	proto.RegisterType((*TextMessage_Filter)(nil), "MurmurRPC.TextMessage.Filter")
	proto.RegisterType((*Log)(nil), "MurmurRPC.Log")
	proto.RegisterType((*Log_Query)(nil), "MurmurRPC.Log.Query")
	proto.RegisterType((*Log_List)(nil), "MurmurRPC.Log.List")
	proto.RegisterType((*Config)(nil), "MurmurRPC.Config")
	proto.RegisterType((*Config_Field)(nil), "MurmurRPC.Config.Field")
	proto.RegisterType((*Channel)(nil), "MurmurRPC.Channel")
	proto.RegisterType((*Channel_Query)(nil), "MurmurRPC.Channel.Query")
	proto.RegisterType((*Channel_List)(nil), "MurmurRPC.Channel.List")
	proto.RegisterType((*User)(nil), "MurmurRPC.User")
	proto.RegisterType((*User_Query)(nil), "MurmurRPC.User.Query")
	proto.RegisterType((*User_List)(nil), "MurmurRPC.User.List")
	proto.RegisterType((*User_Kick)(nil), "MurmurRPC.User.Kick")
	proto.RegisterType((*Tree)(nil), "MurmurRPC.Tree")
	proto.RegisterType((*Tree_Query)(nil), "MurmurRPC.Tree.Query")
	proto.RegisterType((*Ban)(nil), "MurmurRPC.Ban")
	proto.RegisterType((*Ban_Query)(nil), "MurmurRPC.Ban.Query")
	proto.RegisterType((*Ban_List)(nil), "MurmurRPC.Ban.List")
	proto.RegisterType((*ACL)(nil), "MurmurRPC.ACL")
	proto.RegisterType((*ACL_Group)(nil), "MurmurRPC.ACL.Group")
	proto.RegisterType((*ACL_Query)(nil), "MurmurRPC.ACL.Query")
	proto.RegisterType((*ACL_List)(nil), "MurmurRPC.ACL.List")
	proto.RegisterType((*ACL_TemporaryGroup)(nil), "MurmurRPC.ACL.TemporaryGroup")
	proto.RegisterType((*Authenticator)(nil), "MurmurRPC.Authenticator")
	proto.RegisterType((*Authenticator_Request)(nil), "MurmurRPC.Authenticator.Request")
	proto.RegisterType((*Authenticator_Request_Authenticate)(nil), "MurmurRPC.Authenticator.Request.Authenticate")
	proto.RegisterType((*Authenticator_Request_Find)(nil), "MurmurRPC.Authenticator.Request.Find")
	proto.RegisterType((*Authenticator_Request_Query)(nil), "MurmurRPC.Authenticator.Request.Query")
	proto.RegisterType((*Authenticator_Request_Register)(nil), "MurmurRPC.Authenticator.Request.Register")
	proto.RegisterType((*Authenticator_Request_Deregister)(nil), "MurmurRPC.Authenticator.Request.Deregister")
	proto.RegisterType((*Authenticator_Request_Update)(nil), "MurmurRPC.Authenticator.Request.Update")
	proto.RegisterType((*Authenticator_Response)(nil), "MurmurRPC.Authenticator.Response")
	proto.RegisterType((*Authenticator_Response_Initialize)(nil), "MurmurRPC.Authenticator.Response.Initialize")
	proto.RegisterType((*Authenticator_Response_Authenticate)(nil), "MurmurRPC.Authenticator.Response.Authenticate")
	proto.RegisterType((*Authenticator_Response_Find)(nil), "MurmurRPC.Authenticator.Response.Find")
	proto.RegisterType((*Authenticator_Response_Query)(nil), "MurmurRPC.Authenticator.Response.Query")
	proto.RegisterType((*Authenticator_Response_Register)(nil), "MurmurRPC.Authenticator.Response.Register")
	proto.RegisterType((*Authenticator_Response_Deregister)(nil), "MurmurRPC.Authenticator.Response.Deregister")
	proto.RegisterType((*Authenticator_Response_Update)(nil), "MurmurRPC.Authenticator.Response.Update")
	proto.RegisterType((*DatabaseUser)(nil), "MurmurRPC.DatabaseUser")
	proto.RegisterType((*DatabaseUser_Query)(nil), "MurmurRPC.DatabaseUser.Query")
	proto.RegisterType((*DatabaseUser_List)(nil), "MurmurRPC.DatabaseUser.List")
	proto.RegisterType((*DatabaseUser_Verify)(nil), "MurmurRPC.DatabaseUser.Verify")
	proto.RegisterType((*RedirectWhisperGroup)(nil), "MurmurRPC.RedirectWhisperGroup")
	proto.RegisterEnum("MurmurRPC.Server_Event_Type", Server_Event_Type_name, Server_Event_Type_value)
	proto.RegisterEnum("MurmurRPC.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("MurmurRPC.ContextAction_Context", ContextAction_Context_name, ContextAction_Context_value)
	proto.RegisterEnum("MurmurRPC.TextMessage_Filter_Action", TextMessage_Filter_Action_name, TextMessage_Filter_Action_value)
	proto.RegisterEnum("MurmurRPC.ACL_Permission", ACL_Permission_name, ACL_Permission_value)
	proto.RegisterEnum("MurmurRPC.Authenticator_Response_Status", Authenticator_Response_Status_name, Authenticator_Response_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for V1 service

type V1Client interface {
	// GetUptime returns murmur's uptime.
	GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	// Events returns a stream of murmur events.
	Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error)
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error)
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error)
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error)
	// TextMessageFilter filters text messages for a given server.
	//
	// When a filter stream is active, text messages sent from users to the
	// server are sent over the stream. The RPC client then sends a message back
	// on the same stream, containing an action: whether the message should be
	// accepted, rejected, or dropped.
	//
	// To activate the filter stream, an initial TextMessage.Filter message must
	// be sent that contains the server on which the filter will be active.
	TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error)
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error)
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error)
}

type v1Client struct {
	cc *grpc.ClientConn
}

func NewV1Client(cc *grpc.ClientConn) V1Client {
	return &v1Client{cc}
}

func (c *v1Client) GetUptime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Uptime, error) {
	out := new(Uptime)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/GetUptime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) GetVersion(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) Events(ctx context.Context, in *Void, opts ...grpc.CallOption) (V1_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[0], c.cc, "/MurmurRPC.V1/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1EventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_EventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type v1EventsClient struct {
	grpc.ClientStream
}

func (x *v1EventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ServerCreate(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerQuery(ctx context.Context, in *Server_Query, opts ...grpc.CallOption) (*Server_List, error) {
	out := new(Server_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Server, error) {
	out := new(Server)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStart(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerStart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerStop(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerStop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerRemove(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ServerRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ServerEvents(ctx context.Context, in *Server, opts ...grpc.CallOption) (V1_ServerEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[1], c.cc, "/MurmurRPC.V1/ServerEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ServerEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ServerEventsClient interface {
	Recv() (*Server_Event, error)
	grpc.ClientStream
}

type v1ServerEventsClient struct {
	grpc.ClientStream
}

func (x *v1ServerEventsClient) Recv() (*Server_Event, error) {
	m := new(Server_Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) ContextActionAdd(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ContextActionAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionRemove(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ContextActionRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ContextActionEvents(ctx context.Context, in *ContextAction, opts ...grpc.CallOption) (V1_ContextActionEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[2], c.cc, "/MurmurRPC.V1/ContextActionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1ContextActionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type V1_ContextActionEventsClient interface {
	Recv() (*ContextAction, error)
	grpc.ClientStream
}

type v1ContextActionEventsClient struct {
	grpc.ClientStream
}

func (x *v1ContextActionEventsClient) Recv() (*ContextAction, error) {
	m := new(ContextAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) TextMessageSend(ctx context.Context, in *TextMessage, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/TextMessageSend", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TextMessageFilter(ctx context.Context, opts ...grpc.CallOption) (V1_TextMessageFilterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[3], c.cc, "/MurmurRPC.V1/TextMessageFilter", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1TextMessageFilterClient{stream}
	return x, nil
}

type V1_TextMessageFilterClient interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ClientStream
}

type v1TextMessageFilterClient struct {
	grpc.ClientStream
}

func (x *v1TextMessageFilterClient) Send(m *TextMessage_Filter) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1TextMessageFilterClient) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) LogQuery(ctx context.Context, in *Log_Query, opts ...grpc.CallOption) (*Log_List, error) {
	out := new(Log_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/LogQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGet(ctx context.Context, in *Server, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Config_Field, error) {
	out := new(Config_Field)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigSetField(ctx context.Context, in *Config_Field, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigSetField", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ConfigGetDefault(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ConfigGetDefault", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelQuery(ctx context.Context, in *Channel_Query, opts ...grpc.CallOption) (*Channel_List, error) {
	out := new(Channel_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelAdd(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelRemove(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ChannelUpdate(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*Channel, error) {
	out := new(Channel)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ChannelUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserQuery(ctx context.Context, in *User_Query, opts ...grpc.CallOption) (*User_List, error) {
	out := new(User_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserGet(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserUpdate(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) UserKick(ctx context.Context, in *User_Kick, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/UserKick", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) TreeQuery(ctx context.Context, in *Tree_Query, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/TreeQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansGet(ctx context.Context, in *Ban_Query, opts ...grpc.CallOption) (*Ban_List, error) {
	out := new(Ban_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/BansGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) BansSet(ctx context.Context, in *Ban_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/BansSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGet(ctx context.Context, in *Channel, opts ...grpc.CallOption) (*ACL_List, error) {
	out := new(ACL_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLSet(ctx context.Context, in *ACL_List, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLGetEffectivePermissions(ctx context.Context, in *ACL_Query, opts ...grpc.CallOption) (*ACL, error) {
	out := new(ACL)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLGetEffectivePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLAddTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLAddTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) ACLRemoveTemporaryGroup(ctx context.Context, in *ACL_TemporaryGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/ACLRemoveTemporaryGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) AuthenticatorStream(ctx context.Context, opts ...grpc.CallOption) (V1_AuthenticatorStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_V1_serviceDesc.Streams[4], c.cc, "/MurmurRPC.V1/AuthenticatorStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &v1AuthenticatorStreamClient{stream}
	return x, nil
}

type V1_AuthenticatorStreamClient interface {
	Send(*Authenticator_Response) error
	Recv() (*Authenticator_Request, error)
	grpc.ClientStream
}

type v1AuthenticatorStreamClient struct {
	grpc.ClientStream
}

func (x *v1AuthenticatorStreamClient) Send(m *Authenticator_Response) error {
	return x.ClientStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamClient) Recv() (*Authenticator_Request, error) {
	m := new(Authenticator_Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *v1Client) DatabaseUserQuery(ctx context.Context, in *DatabaseUser_Query, opts ...grpc.CallOption) (*DatabaseUser_List, error) {
	out := new(DatabaseUser_List)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserGet(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserUpdate(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserRegister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserRegister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserDeregister(ctx context.Context, in *DatabaseUser, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserDeregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) DatabaseUserVerify(ctx context.Context, in *DatabaseUser_Verify, opts ...grpc.CallOption) (*DatabaseUser, error) {
	out := new(DatabaseUser)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/DatabaseUserVerify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupAdd(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *v1Client) RedirectWhisperGroupRemove(ctx context.Context, in *RedirectWhisperGroup, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/MurmurRPC.V1/RedirectWhisperGroupRemove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for V1 service

type V1Server interface {
	// GetUptime returns murmur's uptime.
	GetUptime(context.Context, *Void) (*Uptime, error)
	// GetVersion returns murmur's version.
	GetVersion(context.Context, *Void) (*Version, error)
	// Events returns a stream of murmur events.
	Events(*Void, V1_EventsServer) error
	// ServerCreate creates a new virtual server. The returned server object
	// contains the newly created server's ID.
	ServerCreate(context.Context, *Void) (*Server, error)
	// ServerQuery returns a list of servers that match the given query.
	ServerQuery(context.Context, *Server_Query) (*Server_List, error)
	// ServerGet returns information about the given server.
	ServerGet(context.Context, *Server) (*Server, error)
	// ServerStart starts the given stopped server.
	ServerStart(context.Context, *Server) (*Void, error)
	// ServerStop stops the given virtual server.
	ServerStop(context.Context, *Server) (*Void, error)
	// ServerRemove removes the given virtual server and its configuration.
	ServerRemove(context.Context, *Server) (*Void, error)
	// ServerEvents returns a stream of events that happen on the given server.
	ServerEvents(*Server, V1_ServerEventsServer) error
	// ContextActionAdd adds a context action to the given user's client. The
	// following ContextAction fields must be set:
	//   context, action, text, and user.
	//
	// Added context actions are valid until:
	//  - The context action is removed with ContextActionRemove, or
	//  - The user disconnects from the server, or
	//  - The server stops.
	ContextActionAdd(context.Context, *ContextAction) (*Void, error)
	// ContextActionRemove removes a context action from the given user's client.
	// The following ContextAction must be set:
	//   action
	// If no user is given, the context action is removed from all users.
	ContextActionRemove(context.Context, *ContextAction) (*Void, error)
	// ContextActionEvents returns a stream of context action events that are
	// triggered by users.
	ContextActionEvents(*ContextAction, V1_ContextActionEventsServer) error
	// TextMessageSend sends the given TextMessage to the server.
	//
	// If no users, channels, or trees are added to the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	TextMessageSend(context.Context, *TextMessage) (*Void, error)
	// TextMessageFilter filters text messages for a given server.
	//
	// When a filter stream is active, text messages sent from users to the
	// server are sent over the stream. The RPC client then sends a message back
	// on the same stream, containing an action: whether the message should be
	// accepted, rejected, or dropped.
	//
	// To activate the filter stream, an initial TextMessage.Filter message must
	// be sent that contains the server on which the filter will be active.
	TextMessageFilter(V1_TextMessageFilterServer) error
	// LogQuery returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	LogQuery(context.Context, *Log_Query) (*Log_List, error)
	// ConfigGet returns the explicitly set configuration for the given server.
	ConfigGet(context.Context, *Server) (*Config, error)
	// ConfigGetField returns the configuration value for the given key.
	ConfigGetField(context.Context, *Config_Field) (*Config_Field, error)
	// ConfigSetField sets the configuration value to the given value.
	ConfigSetField(context.Context, *Config_Field) (*Void, error)
	// ConfigGetDefault returns the default server configuration.
	ConfigGetDefault(context.Context, *Void) (*Config, error)
	// ChannelQuery returns a list of channels that match the given query.
	ChannelQuery(context.Context, *Channel_Query) (*Channel_List, error)
	// ChannelGet returns the channel with the given ID.
	ChannelGet(context.Context, *Channel) (*Channel, error)
	// ChannelAdd adds the channel to the given server. The parent and name of
	// the channel must be set.
	ChannelAdd(context.Context, *Channel) (*Channel, error)
	// ChannelRemove removes the given channel from the server.
	ChannelRemove(context.Context, *Channel) (*Void, error)
	// ChannelUpdate updates the given channel's attributes. Only the fields that
	// are set will be updated.
	ChannelUpdate(context.Context, *Channel) (*Channel, error)
	// UserQuery returns a list of connected users who match the given query.
	UserQuery(context.Context, *User_Query) (*User_List, error)
	// UserGet returns information on the connected user, given by the user's
	// session or name.
	UserGet(context.Context, *User) (*User, error)
	// UserUpdate changes the given user's state. Only the following fields can
	// be changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	UserUpdate(context.Context, *User) (*User, error)
	// UserKick kicks the user from the server.
	UserKick(context.Context, *User_Kick) (*Void, error)
	// TreeQuery returns a representation of the given server's channel/user
	// tree.
	TreeQuery(context.Context, *Tree_Query) (*Tree, error)
	// BansGet returns a list of bans for the given server.
	BansGet(context.Context, *Ban_Query) (*Ban_List, error)
	// BansSet replaces the server's ban list with the given list.
	BansSet(context.Context, *Ban_List) (*Void, error)
	// ACLGet returns the ACL for the given channel.
	ACLGet(context.Context, *Channel) (*ACL_List, error)
	// ACLSet overrides the ACL of the given channel to what is provided.
	ACLSet(context.Context, *ACL_List) (*Void, error)
	// ACLGetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	ACLGetEffectivePermissions(context.Context, *ACL_Query) (*ACL, error)
	// ACLAddTemporaryGroup adds a user to a temporary group.
	ACLAddTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// ACLRemoveTemporaryGroup removes a user from a temporary group.
	ACLRemoveTemporaryGroup(context.Context, *ACL_TemporaryGroup) (*Void, error)
	// AuthenticatorStream opens an authentication stream to the server.
	//
	// There can only be one RPC client with an open Stream. If a new
	// authenticator connects, the open connected will be closed.
	AuthenticatorStream(V1_AuthenticatorStreamServer) error
	// DatabaseUserQuery returns a list of registered users who match given
	// query.
	DatabaseUserQuery(context.Context, *DatabaseUser_Query) (*DatabaseUser_List, error)
	// DatabaseUserGet returns the database user with the given ID.
	DatabaseUserGet(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserUpdate updates the given database user.
	DatabaseUserUpdate(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserRegister registers a user with the given information on the
	// server. The returned DatabaseUser will contain the newly registered user's
	// ID.
	DatabaseUserRegister(context.Context, *DatabaseUser) (*DatabaseUser, error)
	// DatabaseUserDeregister deregisters the given user.
	DatabaseUserDeregister(context.Context, *DatabaseUser) (*Void, error)
	// DatabaseUserVerify verifies the that the given user-password pair is
	// correct.
	DatabaseUserVerify(context.Context, *DatabaseUser_Verify) (*DatabaseUser, error)
	// AddRedirectWhisperGroup add a whisper targets redirection for the given
	// user. Whenever a user whispers to group "source", the whisper will be
	// redirected to group "target".
	RedirectWhisperGroupAdd(context.Context, *RedirectWhisperGroup) (*Void, error)
	// RemoveRedirectWhisperGroup removes a whisper target redirection for
	// the the given user.
	RedirectWhisperGroupRemove(context.Context, *RedirectWhisperGroup) (*Void, error)
}

func RegisterV1Server(s *grpc.Server, srv V1Server) {
	s.RegisterService(&_V1_serviceDesc, srv)
}

func _V1_GetUptime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).GetUptime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/GetUptime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).GetUptime(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).GetVersion(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Void)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).Events(m, &v1EventsServer{stream})
}

type V1_EventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type v1EventsServer struct {
	grpc.ServerStream
}

func (x *v1EventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ServerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerCreate(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerQuery(ctx, req.(*Server_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerGet(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerStart(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerStop(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ServerRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ServerRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ServerRemove(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ServerEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Server)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ServerEvents(m, &v1ServerEventsServer{stream})
}

type V1_ServerEventsServer interface {
	Send(*Server_Event) error
	grpc.ServerStream
}

type v1ServerEventsServer struct {
	grpc.ServerStream
}

func (x *v1ServerEventsServer) Send(m *Server_Event) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_ContextActionAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextAction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ContextActionAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ContextActionAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ContextActionAdd(ctx, req.(*ContextAction))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ContextActionRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextAction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ContextActionRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ContextActionRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ContextActionRemove(ctx, req.(*ContextAction))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ContextActionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContextAction)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(V1Server).ContextActionEvents(m, &v1ContextActionEventsServer{stream})
}

type V1_ContextActionEventsServer interface {
	Send(*ContextAction) error
	grpc.ServerStream
}

type v1ContextActionEventsServer struct {
	grpc.ServerStream
}

func (x *v1ContextActionEventsServer) Send(m *ContextAction) error {
	return x.ServerStream.SendMsg(m)
}

func _V1_TextMessageSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).TextMessageSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/TextMessageSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).TextMessageSend(ctx, req.(*TextMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_TextMessageFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).TextMessageFilter(&v1TextMessageFilterServer{stream})
}

type V1_TextMessageFilterServer interface {
	Send(*TextMessage_Filter) error
	Recv() (*TextMessage_Filter, error)
	grpc.ServerStream
}

type v1TextMessageFilterServer struct {
	grpc.ServerStream
}

func (x *v1TextMessageFilterServer) Send(m *TextMessage_Filter) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1TextMessageFilterServer) Recv() (*TextMessage_Filter, error) {
	m := new(TextMessage_Filter)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_LogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Log_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).LogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/LogQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).LogQuery(ctx, req.(*Log_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Server)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGet(ctx, req.(*Server))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGetField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGetField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGetField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGetField(ctx, req.(*Config_Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigSetField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigSetField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigSetField",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigSetField(ctx, req.(*Config_Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ConfigGetDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ConfigGetDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ConfigGetDefault",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ConfigGetDefault(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelQuery(ctx, req.(*Channel_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelGet(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelAdd(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelRemove(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ChannelUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ChannelUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ChannelUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ChannelUpdate(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserQuery(ctx, req.(*User_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserGet(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserUpdate(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_UserKick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User_Kick)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).UserKick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/UserKick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).UserKick(ctx, req.(*User_Kick))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_TreeQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tree_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).TreeQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/TreeQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).TreeQuery(ctx, req.(*Tree_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_BansGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ban_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).BansGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/BansGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).BansGet(ctx, req.(*Ban_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_BansSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ban_List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).BansSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/BansSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).BansSet(ctx, req.(*Ban_List))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Channel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLGet(ctx, req.(*Channel))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLSet(ctx, req.(*ACL_List))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLGetEffectivePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLGetEffectivePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLGetEffectivePermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLGetEffectivePermissions(ctx, req.(*ACL_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLAddTemporaryGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLAddTemporaryGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLAddTemporaryGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLAddTemporaryGroup(ctx, req.(*ACL_TemporaryGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_ACLRemoveTemporaryGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACL_TemporaryGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).ACLRemoveTemporaryGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/ACLRemoveTemporaryGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).ACLRemoveTemporaryGroup(ctx, req.(*ACL_TemporaryGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_AuthenticatorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(V1Server).AuthenticatorStream(&v1AuthenticatorStreamServer{stream})
}

type V1_AuthenticatorStreamServer interface {
	Send(*Authenticator_Request) error
	Recv() (*Authenticator_Response, error)
	grpc.ServerStream
}

type v1AuthenticatorStreamServer struct {
	grpc.ServerStream
}

func (x *v1AuthenticatorStreamServer) Send(m *Authenticator_Request) error {
	return x.ServerStream.SendMsg(m)
}

func (x *v1AuthenticatorStreamServer) Recv() (*Authenticator_Response, error) {
	m := new(Authenticator_Response)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _V1_DatabaseUserQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser_Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserQuery(ctx, req.(*DatabaseUser_Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserGet(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserUpdate(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserRegister(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserDeregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserDeregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserDeregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserDeregister(ctx, req.(*DatabaseUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_DatabaseUserVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseUser_Verify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).DatabaseUserVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/DatabaseUserVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).DatabaseUserVerify(ctx, req.(*DatabaseUser_Verify))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_RedirectWhisperGroupAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).RedirectWhisperGroupAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/RedirectWhisperGroupAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).RedirectWhisperGroupAdd(ctx, req.(*RedirectWhisperGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _V1_RedirectWhisperGroupRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectWhisperGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(V1Server).RedirectWhisperGroupRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MurmurRPC.V1/RedirectWhisperGroupRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(V1Server).RedirectWhisperGroupRemove(ctx, req.(*RedirectWhisperGroup))
	}
	return interceptor(ctx, in, info, handler)
}

var _V1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MurmurRPC.V1",
	HandlerType: (*V1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUptime",
			Handler:    _V1_GetUptime_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _V1_GetVersion_Handler,
		},
		{
			MethodName: "ServerCreate",
			Handler:    _V1_ServerCreate_Handler,
		},
		{
			MethodName: "ServerQuery",
			Handler:    _V1_ServerQuery_Handler,
		},
		{
			MethodName: "ServerGet",
			Handler:    _V1_ServerGet_Handler,
		},
		{
			MethodName: "ServerStart",
			Handler:    _V1_ServerStart_Handler,
		},
		{
			MethodName: "ServerStop",
			Handler:    _V1_ServerStop_Handler,
		},
		{
			MethodName: "ServerRemove",
			Handler:    _V1_ServerRemove_Handler,
		},
		{
			MethodName: "ContextActionAdd",
			Handler:    _V1_ContextActionAdd_Handler,
		},
		{
			MethodName: "ContextActionRemove",
			Handler:    _V1_ContextActionRemove_Handler,
		},
		{
			MethodName: "TextMessageSend",
			Handler:    _V1_TextMessageSend_Handler,
		},
		{
			MethodName: "LogQuery",
			Handler:    _V1_LogQuery_Handler,
		},
		{
			MethodName: "ConfigGet",
			Handler:    _V1_ConfigGet_Handler,
		},
		{
			MethodName: "ConfigGetField",
			Handler:    _V1_ConfigGetField_Handler,
		},
		{
			MethodName: "ConfigSetField",
			Handler:    _V1_ConfigSetField_Handler,
		},
		{
			MethodName: "ConfigGetDefault",
			Handler:    _V1_ConfigGetDefault_Handler,
		},
		{
			MethodName: "ChannelQuery",
			Handler:    _V1_ChannelQuery_Handler,
		},
		{
			MethodName: "ChannelGet",
			Handler:    _V1_ChannelGet_Handler,
		},
		{
			MethodName: "ChannelAdd",
			Handler:    _V1_ChannelAdd_Handler,
		},
		{
			MethodName: "ChannelRemove",
			Handler:    _V1_ChannelRemove_Handler,
		},
		{
			MethodName: "ChannelUpdate",
			Handler:    _V1_ChannelUpdate_Handler,
		},
		{
			MethodName: "UserQuery",
			Handler:    _V1_UserQuery_Handler,
		},
		{
			MethodName: "UserGet",
			Handler:    _V1_UserGet_Handler,
		},
		{
			MethodName: "UserUpdate",
			Handler:    _V1_UserUpdate_Handler,
		},
		{
			MethodName: "UserKick",
			Handler:    _V1_UserKick_Handler,
		},
		{
			MethodName: "TreeQuery",
			Handler:    _V1_TreeQuery_Handler,
		},
		{
			MethodName: "BansGet",
			Handler:    _V1_BansGet_Handler,
		},
		{
			MethodName: "BansSet",
			Handler:    _V1_BansSet_Handler,
		},
		{
			MethodName: "ACLGet",
			Handler:    _V1_ACLGet_Handler,
		},
		{
			MethodName: "ACLSet",
			Handler:    _V1_ACLSet_Handler,
		},
		{
			MethodName: "ACLGetEffectivePermissions",
			Handler:    _V1_ACLGetEffectivePermissions_Handler,
		},
		{
			MethodName: "ACLAddTemporaryGroup",
			Handler:    _V1_ACLAddTemporaryGroup_Handler,
		},
		{
			MethodName: "ACLRemoveTemporaryGroup",
			Handler:    _V1_ACLRemoveTemporaryGroup_Handler,
		},
		{
			MethodName: "DatabaseUserQuery",
			Handler:    _V1_DatabaseUserQuery_Handler,
		},
		{
			MethodName: "DatabaseUserGet",
			Handler:    _V1_DatabaseUserGet_Handler,
		},
		{
			MethodName: "DatabaseUserUpdate",
			Handler:    _V1_DatabaseUserUpdate_Handler,
		},
		{
			MethodName: "DatabaseUserRegister",
			Handler:    _V1_DatabaseUserRegister_Handler,
		},
		{
			MethodName: "DatabaseUserDeregister",
			Handler:    _V1_DatabaseUserDeregister_Handler,
		},
		{
			MethodName: "DatabaseUserVerify",
			Handler:    _V1_DatabaseUserVerify_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupAdd",
			Handler:    _V1_RedirectWhisperGroupAdd_Handler,
		},
		{
			MethodName: "RedirectWhisperGroupRemove",
			Handler:    _V1_RedirectWhisperGroupRemove_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _V1_Events_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ServerEvents",
			Handler:       _V1_ServerEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ContextActionEvents",
			Handler:       _V1_ContextActionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TextMessageFilter",
			Handler:       _V1_TextMessageFilter_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AuthenticatorStream",
			Handler:       _V1_AuthenticatorStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "MurmurRPC.proto",
}

func init() { proto.RegisterFile("MurmurRPC.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3113 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x1a, 0x4b, 0x73, 0xdb, 0xc6,
	0xd9, 0x00, 0x41, 0x90, 0xfc, 0x48, 0x4a, 0xf0, 0x5a, 0x91, 0x18, 0xd4, 0xae, 0x55, 0x26, 0x6e,
	0xe4, 0x17, 0x63, 0x3b, 0x6f, 0x4f, 0x92, 0x5a, 0x96, 0x2d, 0xc7, 0xb1, 0x94, 0x3a, 0xa0, 0xed,
	0x74, 0x7a, 0x28, 0x0b, 0x11, 0x2b, 0x0a, 0x35, 0x08, 0x20, 0x0b, 0x50, 0x31, 0x7b, 0x52, 0x0f,
	0x9d, 0x1c, 0x72, 0x6e, 0x2f, 0x3d, 0x74, 0x9a, 0x99, 0xce, 0xf4, 0xd0, 0x9f, 0xd0, 0x53, 0x0f,
	0xbd, 0xf4, 0xd0, 0x99, 0xfe, 0x83, 0xce, 0x74, 0xa6, 0x3f, 0xa0, 0x97, 0x1e, 0x3b, 0xfb, 0x00,
	0xb8, 0xe0, 0x1b, 0x72, 0x7b, 0x22, 0xf6, 0x7b, 0xed, 0xb7, 0xdf, 0x6b, 0xbf, 0xdd, 0x25, 0xac,
	0xee, 0x0f, 0x48, 0x7f, 0x40, 0xac, 0xc7, 0x3b, 0xad, 0x90, 0x04, 0x71, 0x80, 0x2a, 0x29, 0xa0,
	0xa9, 0x83, 0xf6, 0x2c, 0x70, 0x9d, 0xa6, 0x07, 0xa5, 0x67, 0x98, 0x44, 0x6e, 0xe0, 0xa3, 0x06,
	0x94, 0x8e, 0xf9, 0x67, 0x43, 0xd9, 0x54, 0xb6, 0xea, 0x56, 0x32, 0xa4, 0x18, 0x82, 0x3d, 0x6c,
	0x47, 0xb8, 0xa1, 0x6e, 0x2a, 0x5b, 0x15, 0x2b, 0x19, 0xa2, 0x15, 0x50, 0x83, 0xa8, 0x51, 0x60,
	0x40, 0x35, 0x88, 0xd0, 0x05, 0x80, 0x20, 0xea, 0x24, 0x62, 0x34, 0x06, 0xaf, 0x04, 0x91, 0x98,
	0xa2, 0x79, 0x1e, 0xf4, 0xa7, 0x61, 0xec, 0xf6, 0x31, 0x42, 0xa0, 0x45, 0xb8, 0x1b, 0xb1, 0x99,
	0x34, 0x8b, 0x7d, 0x37, 0x7f, 0xaf, 0x81, 0xde, 0xc6, 0xe4, 0x18, 0x13, 0x2a, 0xd7, 0x75, 0x1a,
	0xca, 0xa6, 0xba, 0x55, 0xb7, 0x54, 0xd7, 0x61, 0x1a, 0x0c, 0x7c, 0xdf, 0xf5, 0x7b, 0x4c, 0x83,
	0xb2, 0x95, 0x0c, 0xd1, 0x65, 0xd0, 0x07, 0x4c, 0x24, 0xd3, 0xa2, 0x7a, 0xeb, 0x6c, 0x6b, 0xb4,
	0x6a, 0x3e, 0x97, 0x25, 0x08, 0xcc, 0xaf, 0x0b, 0x50, 0xbc, 0x7f, 0x8c, 0xfd, 0x98, 0x32, 0x45,
	0x6c, 0x22, 0x36, 0x7f, 0x96, 0x89, 0x6b, 0x60, 0x09, 0x02, 0x74, 0x03, 0xb4, 0x78, 0x18, 0xf2,
	0x85, 0xaf, 0xdc, 0x3a, 0x3f, 0x41, 0xd8, 0x62, 0x12, 0x5b, 0x4f, 0x86, 0x21, 0xb6, 0x18, 0x25,
	0x7a, 0x0d, 0xb4, 0x41, 0x84, 0x89, 0xd0, 0x67, 0x55, 0xd6, 0x27, 0xc2, 0xc4, 0x62, 0x48, 0x74,
	0x03, 0x4a, 0x7d, 0x1c, 0x45, 0x76, 0x0f, 0x33, 0x2b, 0x55, 0x6f, 0xad, 0x4b, 0x74, 0x4f, 0xf0,
	0x8b, 0x78, 0x9f, 0x63, 0xad, 0x84, 0x0c, 0x5d, 0x83, 0x52, 0xf7, 0xc8, 0xf6, 0x7d, 0xec, 0x35,
	0x8a, 0x8c, 0x03, 0x49, 0x1c, 0x3b, 0x1c, 0x63, 0x25, 0x24, 0xcd, 0xdf, 0x28, 0xa0, 0x51, 0x9d,
	0xd0, 0x59, 0xa8, 0xd3, 0x69, 0x77, 0x02, 0xdf, 0xc7, 0xdd, 0x18, 0x3b, 0xc6, 0x19, 0xb4, 0x06,
	0x06, 0x05, 0xdd, 0x73, 0xa3, 0x6e, 0x0a, 0x55, 0x12, 0x68, 0x3b, 0xb6, 0x63, 0x4c, 0xc5, 0xf5,
	0xb0, 0x63, 0xa8, 0xe8, 0x1c, 0xac, 0x52, 0xa8, 0xa4, 0x91, 0x51, 0x40, 0x08, 0x56, 0xc4, 0x84,
	0x3b, 0x04, 0xdb, 0x94, 0x5d, 0x93, 0x60, 0x16, 0xee, 0x07, 0xc7, 0xd8, 0x31, 0x8a, 0x68, 0x03,
	0xce, 0x09, 0x58, 0x46, 0xaa, 0x6e, 0x96, 0xa0, 0xf8, 0xf9, 0x00, 0x93, 0xa1, 0xf9, 0x16, 0x68,
	0x7b, 0x6e, 0x14, 0xa3, 0xab, 0x50, 0xe2, 0xf6, 0xa6, 0x11, 0x51, 0x98, 0xee, 0x91, 0x84, 0xa2,
	0xf9, 0x8d, 0x72, 0x0a, 0x3f, 0x5e, 0xce, 0xf8, 0xf1, 0x15, 0x89, 0x70, 0xdc, 0x81, 0xcd, 0x6b,
	0x23, 0xd3, 0x71, 0x21, 0xed, 0x38, 0x08, 0x43, 0x66, 0x3a, 0x09, 0x64, 0x13, 0x66, 0xb7, 0xe6,
	0x1f, 0x54, 0xa8, 0xef, 0x04, 0x7e, 0x8c, 0x5f, 0xc4, 0xdb, 0xdd, 0x98, 0xa6, 0x4b, 0x0e, 0xad,
	0x1a, 0x50, 0xea, 0x72, 0x5e, 0xa6, 0x58, 0xdd, 0x4a, 0x86, 0x68, 0x1d, 0x74, 0x9b, 0x89, 0x13,
	0xd9, 0x25, 0x46, 0x34, 0x71, 0x18, 0x39, 0xcf, 0x2d, 0xf6, 0x8d, 0x2e, 0x41, 0xd1, 0xee, 0xc6,
	0x01, 0x11, 0x81, 0x31, 0x11, 0x72, 0x1c, 0x9b, 0x06, 0xa6, 0x3e, 0x2f, 0x30, 0xa5, 0x30, 0x2b,
	0x2d, 0x0e, 0xb3, 0x6b, 0x50, 0x12, 0x6b, 0x47, 0x90, 0x24, 0xaf, 0xa1, 0xa0, 0x2a, 0x94, 0x04,
	0xa9, 0xa1, 0xa2, 0x32, 0x68, 0x54, 0xbe, 0xa1, 0x35, 0xff, 0x52, 0x80, 0xaa, 0x14, 0x49, 0x79,
	0x0c, 0x95, 0x2e, 0x51, 0x9d, 0xbb, 0xc4, 0x4b, 0x50, 0xa4, 0xab, 0xa0, 0x25, 0xa9, 0x30, 0x95,
	0x8c, 0x61, 0x51, 0x0b, 0xca, 0x62, 0x05, 0x51, 0x43, 0x63, 0x94, 0xd3, 0x56, 0x99, 0xd2, 0xa0,
	0x2d, 0x28, 0xc6, 0x04, 0xe3, 0xa8, 0x51, 0x9c, 0x49, 0xcc, 0x09, 0x52, 0xf7, 0xe8, 0x23, 0xf7,
	0x98, 0x7f, 0x53, 0x40, 0xdf, 0x75, 0xbd, 0x98, 0x45, 0xe1, 0xd2, 0x2b, 0xfe, 0x30, 0x0d, 0x00,
	0x1e, 0xb2, 0xaf, 0x4f, 0x2f, 0x10, 0x2d, 0x2e, 0xb9, 0xc5, 0x63, 0x2f, 0x0d, 0x13, 0xa9, 0xbe,
	0x14, 0x96, 0xaa, 0x2f, 0xcd, 0x2b, 0xa0, 0x8b, 0xf8, 0x05, 0xfa, 0xd5, 0xc5, 0x61, 0x6c, 0x9c,
	0xa1, 0xdf, 0x16, 0xfe, 0x19, 0xee, 0xc6, 0x86, 0x42, 0x1d, 0x79, 0x8f, 0x04, 0xa1, 0xa1, 0x36,
	0xff, 0xae, 0x42, 0x61, 0x2f, 0xe8, 0xe5, 0x59, 0xce, 0x79, 0xa8, 0xd0, 0x22, 0x1c, 0xc5, 0x76,
	0x3f, 0x64, 0x2b, 0x2a, 0x58, 0x23, 0x40, 0x6a, 0xb6, 0x82, 0x64, 0xb6, 0x67, 0xa2, 0x48, 0xe4,
	0x99, 0xc5, 0x80, 0x42, 0xdf, 0xf5, 0x45, 0x2e, 0xd1, 0x4f, 0x06, 0xb1, 0x5f, 0x30, 0xc1, 0x14,
	0x62, 0xbf, 0x30, 0x7f, 0xa5, 0x88, 0xa2, 0x93, 0x43, 0xee, 0x1a, 0x14, 0xe3, 0x20, 0xb6, 0x3d,
	0x21, 0x99, 0x0f, 0x92, 0xd9, 0x0a, 0x13, 0xb3, 0x69, 0xe9, 0x6c, 0x68, 0x0b, 0x4a, 0xd8, 0x8f,
	0x89, 0x9b, 0x06, 0xcf, 0x8a, 0x34, 0xcb, 0x5e, 0xd0, 0xb3, 0x12, 0x74, 0xf3, 0x17, 0x2a, 0xe8,
	0x3b, 0x81, 0x7f, 0xe8, 0xe6, 0xb2, 0xeb, 0x3b, 0xa0, 0x1f, 0xba, 0xd8, 0x73, 0xa2, 0x86, 0xca,
	0xc4, 0x5f, 0x90, 0x63, 0x93, 0x49, 0x6b, 0xed, 0x32, 0xfc, 0x7d, 0x3f, 0x26, 0x43, 0x4b, 0x10,
	0x9b, 0x1f, 0x40, 0x55, 0x02, 0x53, 0xbd, 0x9f, 0xe3, 0x21, 0x9b, 0xad, 0x62, 0xd1, 0x4f, 0xba,
	0xe2, 0x63, 0xdb, 0x1b, 0x24, 0x3b, 0x3e, 0x1f, 0xdc, 0x56, 0xdf, 0x57, 0xcc, 0x1f, 0x43, 0x91,
	0xb1, 0xe6, 0xf4, 0x0b, 0x95, 0xaf, 0x4e, 0x91, 0x5f, 0x90, 0xe4, 0x37, 0x7f, 0x57, 0x48, 0x2b,
	0x47, 0x1e, 0xf1, 0xbc, 0x5d, 0xe0, 0xbe, 0xa1, 0xed, 0x02, 0x02, 0xcd, 0xb7, 0xfb, 0x89, 0x6c,
	0xf6, 0x8d, 0xae, 0x80, 0x1e, 0xda, 0x04, 0xfb, 0xb1, 0xd8, 0x70, 0xa7, 0x25, 0xb1, 0xa0, 0xa0,
	0xf9, 0xee, 0xb9, 0xfe, 0xf3, 0xb9, 0xf9, 0xce, 0x08, 0xd0, 0x26, 0x54, 0x1d, 0x1c, 0x75, 0x89,
	0x1b, 0xb2, 0x54, 0xe5, 0x69, 0x2f, 0x83, 0x58, 0xe0, 0xe3, 0x7e, 0x18, 0x10, 0x9b, 0x0c, 0x59,
	0x49, 0x2d, 0x5b, 0x23, 0x00, 0x32, 0xa1, 0x1c, 0x06, 0x91, 0xcb, 0x98, 0xcb, 0x9b, 0xca, 0x56,
	0xd1, 0x4a, 0xc7, 0xe6, 0xad, 0xfc, 0x09, 0x60, 0xda, 0xf9, 0x63, 0x5b, 0x2e, 0x86, 0xea, 0xe2,
	0x62, 0xd8, 0xfc, 0xad, 0x28, 0xe8, 0x39, 0xf7, 0xb9, 0x08, 0x47, 0x51, 0x52, 0xcd, 0xea, 0x56,
	0x32, 0x14, 0xae, 0x2b, 0x4c, 0xb8, 0x4e, 0x93, 0x5c, 0x87, 0x40, 0xeb, 0x0f, 0x62, 0xcc, 0xb6,
	0xb7, 0xb2, 0xc5, 0xbe, 0x29, 0xcc, 0xc1, 0xf6, 0x21, 0xb3, 0x78, 0xd9, 0x62, 0xdf, 0xd4, 0x98,
	0xd1, 0x20, 0x0c, 0x09, 0x8e, 0x22, 0x61, 0xe9, 0x74, 0x8c, 0x2e, 0x83, 0x11, 0x12, 0x37, 0x20,
	0x6e, 0x3c, 0xec, 0x44, 0x21, 0xb6, 0x9f, 0x63, 0xc2, 0x0c, 0x5e, 0xb6, 0x56, 0x13, 0x78, 0x9b,
	0x83, 0xd1, 0x77, 0xa0, 0x12, 0x61, 0xef, 0xb0, 0xc3, 0xe6, 0xac, 0x08, 0x39, 0xd8, 0x3b, 0xdc,
	0xa7, 0xf3, 0x26, 0x48, 0x36, 0x39, 0x8c, 0x90, 0xf7, 0xa8, 0x02, 0xe7, 0xa1, 0x42, 0x70, 0x37,
	0x20, 0x0e, 0x6d, 0x54, 0xab, 0xdc, 0xd7, 0x29, 0x40, 0xde, 0x5a, 0x6b, 0x0b, 0xb7, 0x56, 0x74,
	0x11, 0xaa, 0x81, 0xef, 0xb9, 0x3e, 0xee, 0xb0, 0x46, 0xb9, 0xce, 0x2c, 0x04, 0x1c, 0xd4, 0xc6,
	0xdd, 0x88, 0x6a, 0xe2, 0x3a, 0x9e, 0x40, 0xaf, 0x30, 0x74, 0x99, 0x02, 0x18, 0xb2, 0x09, 0xf5,
	0x83, 0x61, 0x8c, 0xa3, 0x4e, 0x88, 0x09, 0xa5, 0x68, 0xac, 0x32, 0x82, 0x2a, 0x03, 0x3e, 0xc6,
	0xa4, 0x8d, 0xbb, 0x54, 0x9f, 0xa4, 0x53, 0x37, 0x26, 0xf4, 0x11, 0x2d, 0xfb, 0xe8, 0x10, 0x70,
	0x09, 0x56, 0x42, 0x6f, 0xd0, 0x73, 0xfd, 0x4e, 0xd2, 0xb1, 0x9c, 0xdd, 0x54, 0xb6, 0x6a, 0x56,
	0x9d, 0x43, 0x93, 0x36, 0xe0, 0x0d, 0x58, 0x15, 0x64, 0xae, 0x83, 0xfd, 0xd8, 0x8d, 0x87, 0x0d,
	0xc4, 0x5c, 0x29, 0xb8, 0x1f, 0x0a, 0x28, 0x6f, 0x7d, 0xfa, 0x7d, 0x9a, 0x90, 0xe7, 0xf8, 0xa1,
	0x42, 0x0c, 0x29, 0x86, 0x8a, 0x1a, 0x10, 0xdc, 0x58, 0x63, 0x53, 0x24, 0x43, 0x8a, 0xb1, 0x1d,
	0x87, 0xf9, 0xf7, 0x15, 0x8e, 0x11, 0x43, 0xf4, 0x2a, 0x94, 0xe3, 0x6e, 0xd8, 0x09, 0x7c, 0x6f,
	0xd8, 0x58, 0xe7, 0x27, 0x84, 0xb8, 0x1b, 0xfe, 0xd0, 0xf7, 0x86, 0xe8, 0x75, 0x58, 0x19, 0x38,
	0x61, 0x27, 0x74, 0xfd, 0x5e, 0xa7, 0xcf, 0x8c, 0xb5, 0xb1, 0xa9, 0x6c, 0xa9, 0x56, 0x6d, 0xe0,
	0x84, 0x8f, 0x5d, 0xbf, 0xb7, 0x4f, 0x61, 0x94, 0x8a, 0x0a, 0x90, 0xa8, 0x1a, 0x9c, 0x2a, 0xee,
	0x8e, 0xa8, 0x4e, 0x95, 0x92, 0x3f, 0xca, 0x9f, 0x92, 0x69, 0x1b, 0xa3, 0xce, 0x6b, 0x63, 0xd8,
	0x4e, 0xf6, 0xc8, 0xed, 0x3e, 0xcf, 0x23, 0x3a, 0x69, 0x02, 0xd5, 0x79, 0x4d, 0x60, 0xda, 0x6d,
	0x15, 0xe6, 0x76, 0x5b, 0xeb, 0xa0, 0x13, 0x6c, 0x47, 0xe9, 0x49, 0x4f, 0x8c, 0x9a, 0xff, 0xa2,
	0x87, 0x0f, 0x82, 0x73, 0x35, 0x78, 0x52, 0x72, 0xa8, 0x8b, 0x93, 0xe3, 0x2a, 0xad, 0x59, 0xae,
	0xe7, 0x10, 0xec, 0x4f, 0x69, 0xf5, 0xe8, 0xdc, 0x56, 0x4a, 0x30, 0xb2, 0xa6, 0x36, 0xd7, 0x9a,
	0xa7, 0xf0, 0x6d, 0xf3, 0x9f, 0x2a, 0x14, 0xee, 0xda, 0x79, 0x5b, 0xfe, 0x24, 0x86, 0xd5, 0x6c,
	0x0c, 0x23, 0xd0, 0x0e, 0xdc, 0x38, 0x12, 0xc5, 0x90, 0x7d, 0xcf, 0x2a, 0x87, 0x47, 0x76, 0x74,
	0xc4, 0xca, 0x61, 0xc5, 0x62, 0xdf, 0x92, 0x2b, 0x74, 0xd9, 0x15, 0x74, 0x9b, 0x8d, 0xe8, 0x51,
	0x85, 0xd5, 0xc3, 0x82, 0xc5, 0x07, 0xe8, 0x35, 0xa8, 0x3b, 0x03, 0x62, 0xd3, 0x5d, 0x86, 0x97,
	0x8f, 0x32, 0xc3, 0xd6, 0x12, 0x60, 0xfb, 0xb4, 0xb1, 0xfe, 0x34, 0x7f, 0xac, 0x37, 0x41, 0x3b,
	0xb0, 0xfd, 0x24, 0xd4, 0xe5, 0xee, 0xe8, 0xae, 0xed, 0x5b, 0x0c, 0xd7, 0xfc, 0x77, 0x05, 0x0a,
	0xdb, 0x3b, 0x7b, 0xe8, 0x02, 0x80, 0x1d, 0x86, 0xde, 0xb0, 0x73, 0x84, 0x09, 0xdf, 0xdd, 0xcb,
	0x56, 0x85, 0x41, 0x3e, 0xc1, 0x04, 0x8f, 0xd0, 0xd1, 0xe0, 0x20, 0x62, 0x26, 0x4b, 0xd0, 0xed,
	0xc1, 0x41, 0x44, 0xab, 0xb3, 0xeb, 0x1f, 0x61, 0xe2, 0xc6, 0xd8, 0x11, 0x7b, 0xc9, 0x08, 0x80,
	0xae, 0x66, 0x4e, 0x47, 0x1b, 0x92, 0x1e, 0xf7, 0xec, 0xd8, 0x3e, 0xb0, 0x23, 0x2c, 0x25, 0xc8,
	0x15, 0x28, 0xf6, 0x48, 0x30, 0x08, 0xc5, 0x19, 0x69, 0x4d, 0xa2, 0xde, 0xde, 0xd9, 0x6b, 0x3d,
	0xa0, 0x38, 0x8b, 0x93, 0x50, 0x17, 0xd8, 0x9e, 0x17, 0x7c, 0xc5, 0x8c, 0x5c, 0xb7, 0xf8, 0x80,
	0xef, 0x5f, 0xfe, 0x90, 0xed, 0x2f, 0x75, 0x8b, 0x7d, 0x9b, 0xbf, 0x56, 0xa1, 0xc8, 0x58, 0x53,
	0xb7, 0x2b, 0x92, 0xdb, 0x33, 0xea, 0xab, 0xe3, 0xea, 0x37, 0xa0, 0x24, 0x06, 0xc2, 0x2e, 0xc9,
	0x90, 0xb6, 0x28, 0xe2, 0xd3, 0x3e, 0xf0, 0xb0, 0x30, 0x8b, 0x0c, 0x42, 0x6f, 0x43, 0x85, 0xa5,
	0x40, 0xc7, 0x76, 0x1c, 0xd1, 0xf2, 0xcc, 0x5c, 0x7f, 0x99, 0x51, 0x6e, 0x3b, 0x0e, 0xba, 0x0d,
	0x35, 0xce, 0x45, 0xd8, 0x81, 0xbf, 0xa1, 0xcf, 0x67, 0xac, 0x32, 0x62, 0x7e, 0x39, 0x80, 0xae,
	0x27, 0x29, 0x59, 0x9a, 0xcf, 0x24, 0x52, 0xf3, 0x97, 0xca, 0x29, 0xce, 0x02, 0x4b, 0x55, 0x3a,
	0xa9, 0xec, 0x14, 0x16, 0x96, 0x1d, 0xf3, 0xaf, 0xa7, 0x38, 0x3a, 0xe4, 0x2b, 0x6c, 0x4d, 0xd0,
	0xec, 0xae, 0x97, 0x9c, 0x5f, 0x57, 0xb2, 0x71, 0x65, 0x31, 0x1c, 0xba, 0x06, 0x3a, 0x8b, 0xac,
	0xa4, 0xa0, 0x4d, 0x8f, 0x3e, 0x41, 0x23, 0x07, 0x46, 0x31, 0x13, 0x18, 0xe6, 0xb7, 0x0a, 0xac,
	0x3c, 0x49, 0x3a, 0x51, 0x1e, 0x77, 0xff, 0xb7, 0x75, 0x2d, 0x75, 0x29, 0x36, 0xa5, 0xd8, 0x35,
	0xff, 0xa3, 0x00, 0x3c, 0xc6, 0xa4, 0xef, 0xf2, 0x76, 0xb1, 0x0c, 0xda, 0x67, 0x81, 0x8f, 0x8d,
	0x33, 0xa8, 0x02, 0xc5, 0x2f, 0x68, 0xe8, 0x1b, 0x0a, 0xaa, 0x41, 0xf9, 0x09, 0xb1, 0x69, 0xa3,
	0x82, 0x0d, 0x95, 0x22, 0xee, 0xfb, 0x31, 0x26, 0x86, 0x46, 0x3f, 0x59, 0x53, 0x67, 0x94, 0x51,
	0x0d, 0x4a, 0x5f, 0x1c, 0xb9, 0x51, 0x88, 0x89, 0x71, 0xa2, 0xa2, 0x15, 0x00, 0xda, 0xcd, 0xd1,
	0xa6, 0x0d, 0xfb, 0x86, 0x41, 0xc5, 0xee, 0x07, 0xc7, 0xd8, 0xd8, 0x44, 0xab, 0x50, 0xdd, 0xb7,
	0x9f, 0xe3, 0xe4, 0xfa, 0xe2, 0x0e, 0x7a, 0x15, 0xd6, 0x28, 0x20, 0x35, 0x54, 0x82, 0x39, 0x29,
	0x23, 0x03, 0xaa, 0x7b, 0xae, 0xff, 0x3c, 0x85, 0x28, 0x14, 0x22, 0x5f, 0x95, 0x9d, 0x68, 0x08,
	0xf8, 0x16, 0x6d, 0x9c, 0x9c, 0x50, 0x75, 0xe8, 0x66, 0x61, 0x9c, 0x9c, 0x94, 0xd1, 0x0a, 0x94,
	0x2d, 0xdc, 0x73, 0x23, 0xaa, 0xe7, 0xc9, 0x89, 0x81, 0x10, 0xd4, 0x92, 0x71, 0x1b, 0x7b, 0x87,
	0xc6, 0xc9, 0xc9, 0x66, 0xf3, 0x5b, 0x03, 0xea, 0xdb, 0x83, 0xf8, 0x88, 0x36, 0x4c, 0x5d, 0x3b,
	0x0e, 0x88, 0xf9, 0x0f, 0x1d, 0x4a, 0x16, 0xfe, 0x72, 0x80, 0xa3, 0x18, 0x7d, 0x0e, 0x35, 0x7b,
	0x84, 0xc4, 0xc2, 0x61, 0xd7, 0xe5, 0x58, 0x90, 0x79, 0x5b, 0x82, 0x4f, 0x86, 0x62, 0x2b, 0x23,
	0x02, 0x7d, 0x00, 0xda, 0xa1, 0xeb, 0x3b, 0xc2, 0x9f, 0x97, 0x16, 0x8a, 0xda, 0x75, 0x7d, 0xc7,
	0x62, 0x2c, 0xe8, 0x43, 0x28, 0x7e, 0x49, 0x13, 0x54, 0x38, 0xf8, 0xfb, 0x0b, 0x79, 0x59, 0x3a,
	0x5b, 0x9c, 0x09, 0xdd, 0x87, 0x32, 0x11, 0xab, 0x17, 0xa7, 0xb3, 0xcb, 0x0b, 0x05, 0x24, 0xe6,
	0xb2, 0x52, 0x56, 0xf4, 0x08, 0xc0, 0xc1, 0xa9, 0x20, 0x7e, 0x19, 0x76, 0x75, 0xa1, 0xa0, 0x7b,
	0x29, 0x8b, 0x25, 0xb1, 0xa3, 0x1f, 0x80, 0x3e, 0x08, 0x1d, 0x6a, 0x59, 0xbe, 0x23, 0xbc, 0xb1,
	0x50, 0xd0, 0x53, 0x46, 0x6e, 0x09, 0x36, 0xf3, 0x4f, 0x0a, 0xd4, 0x64, 0x63, 0x4f, 0x2d, 0xea,
	0xf4, 0xfc, 0x67, 0x47, 0xd1, 0x57, 0x01, 0x71, 0xc4, 0xe9, 0x38, 0x1d, 0xa3, 0x26, 0xd4, 0xba,
	0x98, 0xc4, 0xee, 0x21, 0x63, 0xe7, 0x35, 0xa1, 0x66, 0x65, 0x60, 0xf4, 0x58, 0x23, 0x8d, 0x3b,
	0xac, 0x2f, 0xe0, 0xe9, 0xb3, 0x2a, 0xc1, 0x3f, 0xa1, 0x2d, 0xc2, 0x75, 0x40, 0x51, 0x4c, 0x02,
	0xbf, 0xd7, 0x91, 0x30, 0xa2, 0x26, 0x9c, 0xe5, 0x98, 0x9d, 0x11, 0xc2, 0xbc, 0x02, 0x1a, 0xf5,
	0x6f, 0x7a, 0x15, 0x3f, 0x7e, 0x40, 0x53, 0x47, 0xab, 0x30, 0x2f, 0x26, 0xe5, 0x79, 0x1d, 0xf4,
	0x43, 0x76, 0x1f, 0x25, 0x16, 0x29, 0x46, 0xe6, 0x7b, 0xa3, 0x70, 0x4f, 0x37, 0x5a, 0x65, 0x89,
	0x8d, 0xd6, 0xfc, 0x00, 0x60, 0xe4, 0x9f, 0x7c, 0xac, 0xef, 0x80, 0xce, 0x3d, 0x92, 0x8f, 0xed,
	0x8f, 0x15, 0xaa, 0x6b, 0x14, 0x06, 0x7e, 0x84, 0xd1, 0x1e, 0x80, 0xeb, 0xbb, 0xb1, 0x6b, 0x7b,
	0xee, 0xcf, 0x93, 0x14, 0xbb, 0x36, 0x27, 0x10, 0x38, 0x5b, 0xeb, 0x61, 0xca, 0x63, 0x49, 0xfc,
	0xc8, 0x1a, 0x4b, 0x59, 0x9e, 0x67, 0xad, 0xc5, 0xf2, 0xe6, 0xe4, 0xec, 0x6d, 0x91, 0xb3, 0x8b,
	0xf3, 0x4e, 0xc8, 0x92, 0x92, 0xf6, 0xa3, 0x24, 0x69, 0xb5, 0x85, 0x11, 0x2e, 0x98, 0x33, 0x59,
	0xbb, 0x2b, 0x65, 0x2d, 0x4f, 0xb6, 0x2b, 0x8b, 0x25, 0x4c, 0x49, 0xdb, 0xbd, 0x4c, 0xda, 0xea,
	0xcb, 0x1a, 0x79, 0x46, 0xde, 0xde, 0x49, 0xf3, 0x96, 0xf7, 0x66, 0x5b, 0x8b, 0x25, 0x8d, 0x25,
	0xee, 0x7b, 0x00, 0x23, 0x07, 0xe6, 0xe9, 0x7e, 0xbf, 0x1d, 0xcf, 0xf8, 0x3b, 0xa0, 0x47, 0xb1,
	0x1d, 0x0f, 0xf8, 0x3b, 0xd7, 0xca, 0x32, 0xba, 0xb4, 0x19, 0xbd, 0x25, 0xf8, 0x96, 0xba, 0xd9,
	0xca, 0xd5, 0x0f, 0x98, 0x6f, 0x89, 0xbc, 0xce, 0x95, 0x14, 0xef, 0x26, 0x09, 0x9e, 0x36, 0x6e,
	0xca, 0x52, 0x8d, 0xdb, 0x50, 0xca, 0xfb, 0x97, 0x37, 0xc6, 0xd5, 0x4c, 0x47, 0xb7, 0x40, 0xe5,
	0xcf, 0x32, 0x95, 0xe3, 0xa5, 0x27, 0x37, 0x3f, 0x4d, 0xcb, 0xc9, 0x4b, 0xcb, 0x6a, 0x3e, 0x04,
	0x9d, 0x43, 0x68, 0xbb, 0xb1, 0x6b, 0x7b, 0x5e, 0x7c, 0x44, 0x82, 0x41, 0xef, 0xc8, 0x38, 0x83,
	0xaa, 0x50, 0x6a, 0x0f, 0xba, 0x5d, 0x1c, 0x45, 0xfc, 0x1d, 0x65, 0xd7, 0x76, 0xbd, 0x01, 0xa1,
	0x7d, 0xcd, 0x1a, 0x18, 0x69, 0x13, 0x92, 0x40, 0x0b, 0xcd, 0x6f, 0x34, 0xa8, 0xc9, 0xab, 0xff,
	0x5f, 0x5f, 0x9b, 0xae, 0x41, 0x11, 0xf7, 0x6d, 0xd7, 0x13, 0xbb, 0x0a, 0x1f, 0xc8, 0x97, 0x37,
	0xc5, 0xec, 0xe5, 0x4d, 0x72, 0x38, 0xd5, 0xa5, 0xc3, 0xa9, 0xbc, 0xc9, 0x95, 0xc6, 0x36, 0xb9,
	0x8b, 0x50, 0xf5, 0xec, 0x28, 0xee, 0xd8, 0xdd, 0xd8, 0x3d, 0xc6, 0xec, 0x8c, 0x54, 0xb1, 0x80,
	0x82, 0xb6, 0x19, 0x44, 0xbe, 0x0d, 0xaa, 0x64, 0x6e, 0x83, 0xcc, 0x4f, 0x4f, 0x71, 0x28, 0x18,
	0x6d, 0x50, 0x6a, 0x66, 0x83, 0xfa, 0x69, 0xfe, 0xc6, 0xfe, 0x7a, 0xf6, 0x92, 0x66, 0x51, 0x2a,
	0x74, 0x41, 0x7f, 0x86, 0x89, 0x7b, 0x98, 0x4b, 0xdd, 0x29, 0x9b, 0x6d, 0xc6, 0x9a, 0x85, 0xac,
	0x35, 0x9b, 0x7f, 0x56, 0x60, 0xcd, 0xc2, 0x8e, 0x4b, 0x70, 0x37, 0x16, 0xed, 0x6e, 0xee, 0xc6,
	0x7e, 0xc9, 0x73, 0x93, 0x1e, 0x05, 0x03, 0xd2, 0x4d, 0x9e, 0x97, 0x66, 0xd4, 0x1c, 0x4e, 0x43,
	0xa9, 0x63, 0x9b, 0xf4, 0x70, 0x72, 0xf7, 0x3e, 0x83, 0x9a, 0xd3, 0xdc, 0xfa, 0x7a, 0x1d, 0xd4,
	0x67, 0x37, 0xd1, 0x9b, 0x50, 0x79, 0x80, 0x63, 0xf1, 0x7f, 0x01, 0x59, 0x8d, 0x67, 0x81, 0xeb,
	0x98, 0x93, 0xef, 0xfc, 0xe8, 0x26, 0xc0, 0x03, 0x1c, 0x27, 0x7f, 0x67, 0x98, 0xe0, 0x98, 0x72,
	0xbb, 0x89, 0xae, 0x83, 0xce, 0x9e, 0x7f, 0xa3, 0x49, 0x72, 0x63, 0xfc, 0x89, 0xf8, 0x86, 0x82,
	0x6e, 0x41, 0x8d, 0x1b, 0x8b, 0xbf, 0x7b, 0xcf, 0xd7, 0x4a, 0xfc, 0x95, 0xe1, 0x63, 0xa8, 0xf2,
	0x2f, 0x1e, 0xab, 0x1b, 0x93, 0xff, 0x20, 0xe0, 0x4f, 0xe1, 0xeb, 0x93, 0x08, 0x16, 0x91, 0x37,
	0xa1, 0xc2, 0x87, 0x0f, 0x70, 0x8c, 0x26, 0xe5, 0x4f, 0x9b, 0xf2, 0x66, 0x32, 0x25, 0x7b, 0xa5,
	0x9e, 0xc6, 0x34, 0xae, 0x38, 0xba, 0x01, 0x30, 0x7a, 0xeb, 0x5e, 0x8a, 0x23, 0xb5, 0x85, 0x38,
	0xd2, 0x2f, 0xc3, 0xf3, 0x61, 0xc2, 0x23, 0x8c, 0x3e, 0x85, 0x67, 0x63, 0xc6, 0x3f, 0x2c, 0x6e,
	0x28, 0xe8, 0x23, 0x30, 0x32, 0x0f, 0xed, 0xdb, 0x8e, 0x83, 0x1a, 0xd9, 0xe7, 0xae, 0x11, 0x72,
	0x72, 0xf2, 0x3b, 0x70, 0x2e, 0x43, 0x21, 0xf4, 0xce, 0x21, 0xe1, 0xd1, 0x98, 0x04, 0xb1, 0x8a,
	0xd9, 0x12, 0x66, 0x62, 0x6e, 0x28, 0xe8, 0x36, 0xac, 0x4a, 0x47, 0xc5, 0x36, 0xf6, 0x1d, 0x34,
	0xe3, 0x8d, 0x76, 0x52, 0x91, 0xa7, 0x70, 0x56, 0xc2, 0x8b, 0xb7, 0xe5, 0x0b, 0x73, 0x1f, 0x88,
	0xcd, 0xf9, 0xe8, 0x2d, 0xe5, 0x86, 0x82, 0xde, 0x81, 0xf2, 0x5e, 0xd0, 0xe3, 0x71, 0xba, 0x96,
	0x7d, 0xa6, 0x14, 0x41, 0x7a, 0x6e, 0x0c, 0x9a, 0x44, 0x28, 0x7f, 0x69, 0x5c, 0x22, 0x42, 0xc5,
	0x03, 0xe7, 0x5d, 0x58, 0x49, 0x59, 0xf8, 0x63, 0xe2, 0xc6, 0x8c, 0x77, 0x4b, 0x73, 0x16, 0x02,
	0xdd, 0x4e, 0x64, 0xb4, 0x17, 0xca, 0x98, 0x30, 0xe0, 0xbb, 0x2c, 0x94, 0xf8, 0xfc, 0xf7, 0xf0,
	0xa1, 0x3d, 0xf0, 0xe2, 0xf9, 0xc9, 0x2c, 0xf4, 0xde, 0x86, 0x9a, 0x38, 0xed, 0x73, 0x2b, 0x35,
	0x26, 0xef, 0x3c, 0x84, 0xa5, 0x36, 0xa6, 0x60, 0x98, 0xb5, 0xde, 0x06, 0x10, 0x63, 0x6a, 0xae,
	0x29, 0x97, 0x26, 0xe6, 0x14, 0x98, 0xc4, 0x45, 0xa3, 0x7e, 0x79, 0xae, 0x7a, 0xe6, 0x4f, 0x39,
	0x53, 0x19, 0x27, 0x8c, 0xf3, 0x5e, 0xca, 0x25, 0x1a, 0x9e, 0x65, 0xa7, 0x7b, 0x1f, 0x2a, 0x74,
	0x8b, 0xe0, 0xa6, 0x79, 0x65, 0x6c, 0xe3, 0x10, 0x76, 0x59, 0x1b, 0x07, 0x27, 0xff, 0xff, 0xa1,
	0x03, 0x6a, 0x91, 0xf1, 0x0d, 0xc7, 0x1c, 0x07, 0xa0, 0x16, 0x00, 0xfd, 0x15, 0xca, 0x2d, 0xa6,
	0xbf, 0x09, 0x65, 0xfa, 0xcb, 0x5e, 0x4a, 0x26, 0xa6, 0xa7, 0xd0, 0x49, 0x13, 0xbc, 0x05, 0x95,
	0x27, 0x04, 0xe3, 0xc9, 0x95, 0x50, 0xa8, 0x58, 0xc9, 0xf8, 0x8b, 0x03, 0x7a, 0x1b, 0x4a, 0x77,
	0x6d, 0x3f, 0xa2, 0x8b, 0x58, 0xcb, 0x5e, 0x63, 0x4f, 0xc9, 0x1e, 0x0a, 0x65, 0x4b, 0x7f, 0x93,
	0x73, 0xb5, 0x71, 0x8c, 0xa6, 0xe1, 0x27, 0x75, 0xbb, 0x09, 0xfa, 0xf6, 0xce, 0xde, 0xac, 0xe0,
	0x39, 0x37, 0xb6, 0xb5, 0xb2, 0x39, 0x5a, 0x8c, 0x65, 0x7c, 0x8a, 0x04, 0x3d, 0x39, 0xc5, 0x5d,
	0x30, 0xf9, 0x14, 0xf7, 0x0f, 0x0f, 0x31, 0x6b, 0xc3, 0x46, 0x57, 0x70, 0x11, 0x1a, 0xdf, 0xbd,
	0xf9, 0xe2, 0xc6, 0xee, 0x2a, 0xd1, 0x2e, 0xac, 0x6d, 0xef, 0xec, 0x6d, 0x3b, 0xce, 0xd8, 0x15,
	0xe3, 0x85, 0x31, 0xee, 0x2c, 0x7a, 0x52, 0x97, 0x87, 0xb0, 0xb1, 0xbd, 0xb3, 0xc7, 0xe3, 0xf7,
	0x25, 0x45, 0xfd, 0x04, 0xce, 0x65, 0xfa, 0xf3, 0x76, 0x4c, 0xb0, 0xdd, 0x47, 0xdf, 0x5b, 0xd8,
	0xbf, 0x9b, 0x9b, 0x8b, 0x2e, 0x7f, 0x58, 0xfd, 0x7c, 0x0c, 0x67, 0xe5, 0xce, 0x8f, 0x47, 0xcf,
	0x85, 0x19, 0x7d, 0xa1, 0x30, 0xdb, 0xf9, 0x59, 0x68, 0xe6, 0xb8, 0x1d, 0x58, 0x95, 0x81, 0xd4,
	0xe9, 0xb3, 0xfa, 0x4c, 0x73, 0x16, 0x02, 0x7d, 0x0c, 0x48, 0x1e, 0x8b, 0xbc, 0x99, 0x29, 0x67,
	0xc2, 0x6c, 0x9f, 0xc0, 0x5a, 0xa6, 0xa1, 0x4d, 0xce, 0x54, 0xf9, 0x35, 0xb9, 0x0b, 0xeb, 0xf2,
	0x58, 0x3a, 0x9f, 0x2d, 0xaf, 0xcd, 0x7e, 0x76, 0x35, 0xa2, 0xa7, 0xfe, 0xee, 0x2c, 0x33, 0x72,
	0xfc, 0x6c, 0x95, 0x1e, 0xc1, 0xc6, 0xb4, 0x86, 0x99, 0x56, 0xd9, 0x8b, 0x12, 0xcf, 0x34, 0x9a,
	0x49, 0xdd, 0x3e, 0x03, 0x73, 0x1a, 0xa1, 0x28, 0xbe, 0xb9, 0xe5, 0xfd, 0x37, 0x00, 0x00, 0xff,
	0xff, 0xfa, 0x66, 0x13, 0x75, 0xc2, 0x2b, 0x00, 0x00,
}
